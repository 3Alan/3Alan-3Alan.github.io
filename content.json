{"meta":{"title":"Alan|前端博客","subtitle":"","description":"一个专注于前端开发的小白，分享前端开发知识","author":"Alan","url":"https://alanwang.site","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-05-13T09:03:12.444Z","updated":"2020-05-13T09:03:12.444Z","comments":true,"path":"404.html","permalink":"https://alanwang.site/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2020-05-14T12:42:42.500Z","updated":"2020-05-14T12:42:42.500Z","comments":true,"path":"about/index.html","permalink":"https://alanwang.site/about/index.html","excerpt":"","text":"Alan 待完善"},{"title":"所有分类","date":"2020-05-14T12:46:25.030Z","updated":"2020-05-14T12:46:25.030Z","comments":true,"path":"categories/index.html","permalink":"https://alanwang.site/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-05-14T12:58:35.975Z","updated":"2020-05-14T12:58:35.975Z","comments":true,"path":"tags/index.html","permalink":"https://alanwang.site/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-14T13:02:13.019Z","updated":"2020-05-14T13:02:13.019Z","comments":true,"path":"list/index.html","permalink":"https://alanwang.site/list/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-05-14T13:25:42.778Z","updated":"2020-05-14T13:25:42.778Z","comments":true,"path":"friends/index.html","permalink":"https://alanwang.site/friends/index.html","excerpt":"","text":"要添加友链的朋友按照下面格式给我留言😘 items: - name: # 博客名 必填 avatar: # 头像链接 必填 url: # 博客链接 必填 backgroundColor: &#39;#3E74C9&#39; # 卡片背景颜色 textColor: &#39;#fff&#39; # 卡片文字颜色 tags: [标签1, 标签2] # 标签 desc: 描述文字"}],"posts":[{"title":"webpack4.0进阶（三）","slug":"webpack4-0进阶（三）","date":"2020-06-05T02:24:19.000Z","updated":"2020-06-12T03:19:00.000Z","comments":true,"path":"2020/06/05/webpack4-0进阶（三）/","link":"","permalink":"https://alanwang.site/2020/06/05/webpack4-0%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"手写简单的loader、Plugin、简单的webpack","text":"手写简单的loader、Plugin、简单的webpack 手写简单的loader目录 myLoader ├── loaders │ └── myLoader.js ├── package.json ├── src │ └── index.js └── webpack.config.js index.jswebpack.config.jsmyLoader.jsconsole.log('hello webpack!');const path =require('path'); module.exports = { mode: 'development', entry: './src/index.js', module: { rules: [{ test: /\\.js$/, exclude: /node_modules/, use: [ { loader: path.resolve(__dirname, './loaders/myLoader.js'), options: { key: 'my option value', }, }, ], }], }, output: { path: path.resolve(__dirname, 'dist'), filename: '[name].js', }, };module.exports = function (source) { return source.replace('webpack', this.query.key); } 这个例子非常简单，就是通过自建的loader将项目中的webpack字符串替换成webpack中配置的字符串。myLoader.js中可以通过this.query接受webpack中配置的options参数。更多this上的属性参考（包括异步处理、回调…） 上面的例子通过打包后代码如下 console.log(&#39;hello my option value!&#39;) webpack5中可以直接通过this.getOptions (schema)来获取options参数 webpack resolveLoader: 和之前提到的resolve的使用类似，就是用来偷懒的😂 使用resolveLoader改写后的wepack.config.js const path =require(&#39;path&#39;); module.exports = { mode: &#39;development&#39;, entry: &#39;./src/index.js&#39;, resolveLoader: { modules: [&#39;node_modules&#39;, &#39;./loaders&#39;], }, module: { rules: [{ test: /\\.js$/, exclude: /node_modules/, use: [ { loader: &#39;myLoader&#39;, options: { key: &#39;my option&#39;, }, }, ], }], }, output: { path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;[name].js&#39;, }, }; 自定义的loader中不要使用箭头函数，会产生this指向问题 手写简单的Plugin目录 myPlugin ├── package.json ├── plugins │ └── date-webpack-plugin.js ├── src │ └── index.js └── webpack.config.js complier提供了许多钩子，可以让我们在打包的不同时刻来进行不同的处理，这里使用了emit钩子 下面通过手写的plugin来实现在dist目录下生成一个author.txt文件 date-webpack-plugin.jswebpack.config.jsclass DateWebpackPlugin { constructor(options) { // options时new插件时传进来的参数 this.options = options; } apply(compiler) { const _this = this; compiler.hooks.emit.tapAsync('DateWebpackPlugin', (compilation, cb) =&gt; { compilation.assets['author.txt'] = { // 返回的资源 source: function () { return `created by ${_this.options.author} ${new Date()}`; }, // 最后生成的文件大小 size: function () { return 19; } }; // 由于emit是异步操作，所以最后要执行回调函数 cb(); }) } } module.exports = DateWebpackPlugin;const path = require('path'); const DateWebpackPlugin = require('./plugins/date-webpack-plugin'); module.exports = { mode: 'development', entry: './src/index.js', output: { path: path.resolve(__dirname, 'dist'), filename: '[name].js', }, plugins: [ new DateWebpackPlugin({ author: 'Alan', }), ], }; 打包后会在dist目录下自动生成一个author.txt文件，内容如下 created by AlanSun Jun 07 2020 11:49:42 GMT+0800 (GMT+08:00)react和vue脚手架webpack配置 create-react-app通过npm run eject暴露webpack配置 vue-cli通过vue.config.js配置webpack(可以通过configureWebpack自定义webpack配置) 手写一个简单的webpack打包工具先提前安装以下需要的插件 npm i @babel/parser -D // 将js内容转化为抽象语法树 npm i @babel/traverse -D // 用来遍历抽象语法树 npm i @babel/core -D npm i @babel/preset-env -D //es6-&gt;es5 npm i cli-highlight -D // 可选，命令行高亮插件，使用方式 node in前置知识： node： fs.readFileSync(同步读取文件内容) path_dirname(获取文件的目录) 项目目录： bundler ├── bundler.js // 主要文件 └── src ├── course.js ├── index.js └── learn.js index.jslearn.jscourse.jsimport notify from './learn.js'; console.log(notify);import { course } from './course.js'; const learnNotify = `time to learn ${course}`; export default learnNotify;export const course = 'webpack'; 我将整个项目拆分成2个部分来分析 处理入口文件找到所有import文件思路： 通过fs.readFileSync读取index.js的内容 使用@babel/parser将读取的内容转化为AST抽象语法树 使用@babel/traverse遍历找到所有import语句 分析出引用的文件，保存其路径 代码： const fs = require(&#39;fs&#39;); const parser = require(&#39;@babel/parser&#39;); const traverse = require(&#39;@babel/traverse&#39;).default; // 命令行高亮工具 const highlight = require(&#39;cli-highlight&#39;).highlight const moduleAnalysis = (filename) =&gt; { // 读取出index.js文件内容 const content = fs.readFileSync(filename, &#39;utf-8&#39;); // 将文件内容转化为抽象语法树 const ast = parser.parse(content, { sourceType: &#39;module&#39; }); // 遍历抽象语法树 traverse(ast, { ImportDeclaration({ node }) { console.log(node); } }) // console.log(highlight(ast)); console.log(ast.program.body); } moduleAnalysis(&#39;./src/index.js&#39;); 通过上图可以清楚看到我们现在要做的事情就是找到所有为type为importDeclaration的node属性 最后对js文件进行babel处理，转化成浏览器能够识别的代码，完整的bundler.js文件如下 const fs = require(&#39;fs&#39;); const parser = require(&#39;@babel/parser&#39;); const traverse = require(&#39;@babel/traverse&#39;).default; const path = require(&#39;path&#39;); const babel = require(&#39;@babel/core&#39;); // 命令行高亮工具 const highlight = require(&#39;cli-highlight&#39;).highlight const moduleAnalysis = (filename) =&gt; { // 读取出index.js文件内容 const content = fs.readFileSync(filename, &#39;utf-8&#39;); // 将文件内容转化为抽象语法树 const ast = parser.parse(content, { sourceType: &#39;module&#39; }); const dependencies = {}; // 遍历抽象语法树 traverse(ast, { ImportDeclaration({ node }) { // 文件对应目录./src const dirPath = path.dirname(filename); // 绝对路径src\\\\learn.js(window操作系统) const filePath = path.join(dirPath, node.source.value); dependencies[node.source.value] = filePath; // { &#39;./learn.js&#39;: &#39;src\\\\learn.js&#39; } console.log(dependencies); } }); // 转化成浏览器可以执行的代码 const { code } = babel.transformFromAst(ast, null, { presets: [&#39;@babel/preset-env&#39;] }); console.log(highlight(code)); return { filename, dependencies, code } } moduleAnalysis(&#39;./src/index.js&#39;);","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"webpack4.0进阶（二）","slug":"webpack4-0进阶（二）","date":"2020-06-03T07:58:33.000Z","updated":"2020-06-03T07:58:33.000Z","comments":true,"path":"2020/06/03/webpack4-0进阶（二）/","link":"","permalink":"https://alanwang.site/2020/06/03/webpack4-0%E8%BF%9B%E9%98%B6%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"TS、Eslint、webpack性能优化","text":"TS、Eslint、webpack性能优化 基础内容打包TS文件使用ts-loader npm i ts-loader typescript -D项目目录如下： ts-test ├── dist │ └── main.js ├── package.json ├── src │ └── index.tsx ├── tsconfig.json └── webpack.config.js tsconfig.json为TS的配置文件，更多配置查看 {% tabs 1 %} ```js interface person { name: string; ts?: boolean; } function Recruit(personObj:person) : string{ if(personObj.ts) { return `congratulations!${personObj.name}`; } else { return `sorry,${personObj.name}, we need a employee who know ts!`; } } let person1 = {name: 'Alan', age: 21, ts: true}; console.log(Recruit(person1)); let person2 = {name: 'Bob', age: 21}; console.log(Recruit(person2)); ``` ```json { \"compilerOptions\": { \"outDir\": \"./dist/\", // 由于webpack中配置了，这里可配可不配 \"module\": \"es6\", \"target\": \"es5\", \"allowJs\": true } } ``` ```js const path = require('path'); module.exports = { mode: 'production', entry: './src/index.tsx', module: { rules: [ { test: /\\.tsx?$/, exclude: /node_modules/, use: 'ts-loader', } ] }, output: { filename: '[name].js', path: path.resolve(__dirname, 'dist') } } ``` {% endtabs %} 当我们项目安装了三方库时并且要在ts文件中使用，得安装该三方库的definitions，具体库可以在TypeSearch查找 devServer.historyApiFallback开发环境下使用单页应用需要配置devServer.historyApiFallback： true EslintEslint是用来统一代码风格的，在团队协作时能够保证每个人书写出的代码风格都是统一的，有利于代码的维护。 使用方式： npm i eslint -D初始化配置 npx eslint --init 初始化配置后我们就可以使用了，这里我安装的是airbnb标准。 上面图片中eslint提示jsx语法不能在js文件中使用，这。。。。😰。那我就是要使用怎么办，可以在生成的.eslintrc.js文件中配置rules忽略这一标准。 rules: { &#39;react/jsx-filename-extension&#39;: 0, }, 由于团队协作很难确保每个人的开发环境都是一样的，于是我们可以把eslint和webpack结合起来，使用一个loader在每次打包时对代码进行eslint检查，但是这样可能会影响打包速度，使用时要对速度和代码质量进行取舍。这里介绍一下使用到的eslint-loader npm i eslint-loader -Dwebpack.common.js配置 rules: [ { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 use: [&#39;babel-loader&#39;, &#39;eslint-loader&#39;], }, ], 当然也可以设置devServer.overlay: true来实现错误实时显示在浏览器上，方便调试。 多页应用打包需要设置多个entry，打包后生成多个.html文件。 src ├── index.html ├── index.js └── list.js // webpack的entry和plugins的配置 entry: { main: &#39;./src/index.js&#39;, // 打包入口文件 list: &#39;./src/list.js&#39;, }, plugins: [ new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, filename: &#39;index.html&#39;, chunks: [&#39;main&#39;], }), new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, filename: &#39;list.html&#39;, chunks: [&#39;list&#39;], }), new CleanWebpackPlugin(), ], 打包后生成的目录 dist ├── index.html ├── list.8c4e5ed5eb6302c4c5ef.js ├── list.8c4e5ed5eb6302c4c5ef.js.map ├── list.html ├── main.acc2939e4489e5d76660.js ├── main.acc2939e4489e5d76660.js.map ├── vendorslistmain.2d42972bf2bf50e6d3cd.js └── vendorslistmain.2d42972bf2bf50e6d3cd.js.map 现在只有两个页面还好说，但是当页面一多我们就要配置多个HtmlWebpackPlugin。那如何让它自动配置呢，这里封装一个函数处理一下就好了 const generateHtmlPlugin = (entry) =&gt; { const plugins = [ new CleanWebpackPlugin(), new webpack.ProvidePlugin({ _: &#39;lodash&#39;, }), ]; Object.keys(entry).forEach((item) =&gt; { plugins.push( new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, filename: `${item}.html`, chunks: [item], }), ); }); return plugins; }; webpack完整配置（webpack.common.js） const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;); const webpack = require(&#39;webpack&#39;); const generateHtmlPlugin = (entry) =&gt; { const plugins = [ new CleanWebpackPlugin(), new webpack.ProvidePlugin({ _: &#39;lodash&#39;, }), ]; Object.keys(entry).forEach((item) =&gt; { plugins.push( new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, filename: `${item}.html`, chunks: [item], }), ); }); return plugins; }; const configs = { mode: &#39;development&#39;, // 默认为production entry: { main: &#39;./src/index.js&#39;, // 打包入口文件 list: &#39;./src/list.js&#39;, }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 use: [&#39;babel-loader&#39;], }, ], }, optimization: { usedExports: true, splitChunks: { chunks: &#39;all&#39;, }, }, output: { path: path.resolve(__dirname, &#39;dist&#39;), }, }; configs.plugins = generateHtmlPlugin(configs.entry); module.exports = configs; webpack性能优化Loader 减少使用不必要的Loader 合理使用exclude和include来针对性的使用loader Plugin 减少不必要的plugin的使用 Resolve（偷懒用的？😂） 减少extensions的使用 减少mainFiles的使用 减少alias的使用 extensions的使用 配置了extensions后可以不写扩展名🤣 目录文件 webpacktest ├── package.json ├── src │ ├── index.html │ ├── index.js │ └── tool │ └── tool.jsx ├── webpack.common.js ├── webpack.dev.js └── webpack.prod.js webpack.config.jsindex.jstool.jsxresolve: { extensions: ['.js', '.jsx'], },import tool from './tool/tool'; tool();export default function Tool() { console.log('my tool'); } 设置了extensions后，webpack由于找不到./tool/tool会先去寻找./tool/tool.js，如果没找到再去寻找./tool/tool.jsx。 mainFiles的使用 配置了mainFiles后可以不写默认文件（说白了就是偷懒😎） 修改index.js文件 import tool from &#39;./tool/&#39;; tool(); webpack配置 resolve: { extensions: [&#39;.js&#39;, &#39;.jsx&#39;], mainFiles: [&#39;index&#39;, &#39;tool&#39;], }, 设置了mainFiles后，webpack会先去寻找./tool/index.js和./tool/index.jsx ，如果没找到再去寻找./tool/tool.js和./tool/tool.jsx。 alias的使用 偷懒神器，免去写长长的路径。 修改index.js文件 import tool from &#39;myTool&#39;; //这里使用的是别名alias tool(); webpack配置 resolve: { extensions: [&#39;.js&#39;, &#39;.jsx&#39;], mainFiles: [&#39;index&#39;, &#39;tool&#39;], alias: { myTool: path.resolve(__dirname, &#39;./src/tool/tool.jsx&#39;), }, }, 这样就可以使用别名myTool来直接引用tool.jsx文件了。 DllPlugin优化项目中第三方模块的打包速度 多进程打包多进程打包插件有：thread-loader，parallel-webpack，happypack sourceMap根据不同环境来配置不同的sourceMap最大程度上优化打包速度 status.json通过status.json文件来分析打包过程，找到最影响性能的地方对症下药。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"前端面试题","slug":"前端面试题","date":"2020-05-31T08:41:48.000Z","updated":"2020-06-01T09:10:00.000Z","comments":true,"path":"2020/05/31/前端面试题/","link":"","permalink":"https://alanwang.site/2020/05/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"记录了自己疫情期间自学+复习总结的一些面试题，虽然期间只面试了一家。😥（拿到了offer（实习），个人原因没去）","text":"记录了自己疫情期间自学+复习总结的一些面试题，虽然期间只面试了一家。😥（拿到了offer（实习），个人原因没去） 背景由于今年疫情的原因以及一些个人原因，辞去了之前的实习工作。在家待了也快3个月了。去年在公司实习错过了秋招，今年又碰上疫情，对我这个应届生来说简直是难上加难。在家这段时间自己学习了React、webpack。用React搭建了一直想做但是耽搁了半年的博客，搭建出来后考虑后期维护成本（服务器费用），就没有继续维护了。改用了Hexo+github搭建了一个静态博客。真香😂。 JS原型 深拷贝和浅拷贝在JS中，变量分为了基本类型和引用类型。对基本类型进行赋值时是对值进行拷贝的，而对引用类型进行赋值则是对地址进行拷贝。 基本类型引用类型let a = 1; let b= a; console.log(a); // 1 a++; console.log(a); // 2 console.log(b); // 1const obj = { name: 'Alan', age: 22, } const cloneObj = obj; obj.age = 18; console.log(cloneObj.age); // 18 通过上面的例子我们知道，cloneObj和obj是指向同一个地址的，任何一方修改都会影响到对方，那如何创建一个独立的cloneObj?，这就要使用深拷贝和浅拷贝了。 深拷贝和浅拷贝的区别： 根据拷贝的层级进行区分，浅拷贝只进行一层拷贝，深拷贝进行多层拷贝。 浅拷贝 方法1方法2const obj = {a:1, b:{b1:1, b2:2}, c:0}; function shallowClone(source) { const result= {}; for (const key in source) { if (source.hasOwnProperty(key)) { result[key] = source[key]; } } return result; } const shallowObj = shallowClone(obj); obj.a = 10; console.log(shallowObj.a); // 1 obj.b.b1 = 6; console.log(shallowObj.b.b1); // 6const obj = {a:1, b:{b1:1, b2:2}, c:0}; function shallowClone1(source) { return Object.assign({}, source); } const shallowObj = shallowClone1(obj); obj.a = 10; console.log(shallowObj.a); // 1 obj.b.b1 = 6; console.log(shallowObj.b.b1); // 6 深拷贝 方法1方法2const obj = {a:1, b:{b1:1, b2:2}, c:0}; function deepClone(source) { const result = {}; for (const key in source) { if (source.hasOwnProperty(key)) { if (typeof source[key] === 'object') { result[key] = deepClone(source[key]); } else { result[key] = source[key]; } } } return result; } const deepObj = deepClone(obj); obj.a = 10; console.log(deepObj.a); // 1 obj.b.b1 = 6; console.log(deepObj.b.b1); // 1const obj = {a:1, b:{b1:1, b2:2}, c:0}; function deepClone(source) { return JSON.parse(JSON.stringify(source)); } const deepObj = deepClone(obj); obj.a = 10; console.log(deepObj.a); // 1 obj.b.b1 = 6; console.log(deepObj.b.b1); // 1 数组去重方法1方法2方法3 Set// 笨方法 const arr = [1,3,45,6,3,2,0]; const newArr = []; let isRepeat; for (let i = 0; i &lt; arr.length; i++) { isRepeat = false; for (let j = 0; j &lt; newArr.length; j++) { if (arr[i] === newArr[j]) { isRepeat = true; break; } } if (!isRepeat) { newArr.push(arr[i]); } } console.log(arr); // [1, 3, 45, 6, 3, 2, 0] console.log(newArr); // [1, 3, 45, 6, 2, 0]const arr = [1,3,45,6,3,2,0]; const newArr = arr.filter((item,index) =&gt; { return arr.indexOf(item) === index }) console.log(arr); // [1, 3, 45, 6, 3, 2, 0] console.log(newArr); // [1, 3, 45, 6, 2, 0]const arr = [1,3,45,6,3,2,0]; const newArr = [...new Set(arr)]; console.log(arr); // [1, 3, 45, 6, 3, 2, 0] console.log(newArr); // [1, 3, 45, 6, 2, 0] for in 和 for of for in 会遍历数组中的可枚举属性，包括原型。可以遍历对象 for of只是遍历数组的元素或者可以迭代的对象。但是不能遍历对象 Array.prototype.testMethod = function () { console.log(&#39;testMethod&#39;); } const mArr = [1,2,3,7]; const mObject = { name: &#39;Alan&#39;, age: 1 } for (const key in mArr) { console.log(mArr[key]); // 1 2 3 7 /* ƒ () { console.log(&#39;testMethod&#39;); } */ } // 解决方案 for (const key in mArr) { if (mArr.hasOwnProperty(key)) { console.log(mArr[key]); // 1 2 3 7 } } for (const key in mObject) { console.log(key); // name // age } try { for (const iterator of mObject) { console.log(iterator); } } catch (error) { console.log(error); //mObject is not iterable } 事件委托事件委托利用了事件冒泡，只指定了一个事件处理程序，就可以管理某一类型的所有事件。 例如，click事件会一直冒泡到document层次。例如下面例子中我们无需对所有li元素添加onclick事件，只需使用事件冒泡的特性来实现事件委托。 &lt;body&gt; &lt;ul id=&quot;myList&quot;&gt; &lt;li id=&quot;sayName&quot;&gt;Name&lt;/li&gt; &lt;li id=&quot;sayHello&quot;&gt;Hello&lt;/li&gt; &lt;li id=&quot;sayAge&quot;&gt;Age&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const myList = document.getElementById(&#39;myList&#39;); myList.addEventListener(&#39;click&#39;, function (e) { const target = e.target; if (target.id === &#39;sayName&#39;) { alert(&#39;Alan&#39;); } else if(target.id === &#39;sayHello&#39;) { alert(&#39;Hello&#39;); } else { alert(&#39;sayAge&#39;); } }) &lt;/script&gt; &lt;/body&gt; 实现滑动动画&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt; &lt;script&gt; const myDiv = document.getElementById(&#39;myDiv&#39;); const time = Date.now(); //时间戳 const transition = setInterval(() =&gt; { const timeLength = Date.now() - time; const step = (5000 - timeLength) / 1000; console.log(step); if (timeLength &gt; 5000) { clearInterval(transition); // 5s后结束 } myDiv.style.left = myDiv.offsetLeft + step + &#39;px&#39;; }, 50); &lt;/script&gt; 数组扁平化方法1方法2方法3方法3// 笨方法：递归 const arr = [1,2,7,[2,[2,3],6]]; function flat(arr) { let result = []; for (let i = 0; i &lt; arr.length; i++) { if(Array.isArray(arr[i])) { result = result.concat(flat(arr[i])); } else { result.push(arr[i]); } } return result; } console.log(flat(arr));// 使用for of let arr = [1,2,7,[2,[2,3],6]]; function flat(arr) { let newArr =[]; for (const item of arr) { if(Array.isArray(item)){ newArr = newArr.concat(flat(item)); } else { newArr.push(item); } } return newArr; } console.log(flat(arr));const arr = [1,2,7,[2,[2,3],6]]; function flat(arr) { while (arr.some(item =&gt; Array.isArray(item))) { arr = [].concat(...arr); } return arr; } console.log(flat(arr));// 骚操作 const arr = [1,2,7,[2,[2,3],6]]; function flat(arr) { const result = arr.toString().split(',').map(item =&gt; { return +item; }); return result; } console.log(flat(arr)); eventLoopJS是单线程的，那为什么不是多线程的呢，设想一个场景，一个线程修改了body的background为red，另一个线程修改了body的background为green。那最终浏览器就不知道background到底为什么。由此可以看到多线程会为浏览器的DOM操作带来很多同步问题。 JS的任务可以分为同步任务和异步任务。 1.同步任务优先在主线程上执行，会形成一个执行栈。 2.异步任务会被放入任务队列中，当执行栈清空时会读取任务队列中的任务丢进执行栈中。 1、2两步反复执行形成了eventLoop。 如果将任务细分的话还可以分成宏任务和微任务： macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise.then()，process.nextTick 优先级：process.nextTick&gt;Promise.then() 详细查看文章这一次，彻底弄懂 JavaScript 执行机制 this 指向调用它的那个对象，函数运行时获得的。 箭头函数的this指向取决于定义时最近一层的非箭头函数的this值。取决于外部的上下文。 求数组最大值const arr = [1,2,1,4,2,10]; console.log(Math.max.apply(null, arr)); const arr = [1,2,1,4,2,10]; console.log(arr.sort((a,b) =&gt; (a-b))[arr.length-1]); const arr = [1,2,1,4,2,10]; console.log(Math.max(...arr)); Promise// new Promise(executor)，当new Promise被创建，executor自动执行 let promise = new Promise(function (resolve, reject) { resolve(&#39;finished&#39;); // reject(new Error); }); // Promise.then(f1,f2) f1在resolve后运行（参数为resolve结果），f2在reject后运行（参数为reject错误） promise.then( result =&gt; console.log(result), //finished error =&gt; console.log(error) //输出错误 ); promise.all()同时执行多个promise，只要有一个promise被reject，那么将不再执行 promise.allSettled()和promise.all()类似，只是会等所有promise执行完。 promise.race()返回最快执行完的promise结果。 https://zh.javascript.info/promise-basics 防抖和节流 节流 函数在一定时间内只执行一次，比如点击按钮后回去服务器获取数据，使用节流可以防止短时间内请求多次，减少服务器的压力 防抖 在一定时间后才执行（触发多次只会执行一次）。应用场景：input搜索框在wait秒后再发送请求 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body { height: 4000px; width: 100px; background: rgb(241, 165, 165); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;fetchBtn&quot;&gt;fetch data&lt;/button&gt; &lt;span&gt;searchBar&lt;/span&gt;&lt;input id=&quot;inputBar&quot;/&gt; &lt;script&gt; // 节流 function throttle(func, wait) { let last = 0; return function (...args) { let now = new Date(); if (now - last &gt; wait) { last = now; func.apply(this, args); } } } // 防抖 function debounce(func, wait) { let timer = 0; return function (...args) { if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; { func.apply(this, args); }, wait) } } document.getElementById(&#39;fetchBtn&#39;).addEventListener(&#39;click&#39;, throttle(function (numb) { console.log(&#39;fetching&#39;); },1000)); document.getElementById(&#39;inputBar&#39;).addEventListener(&#39;input&#39;, debounce(function (numb) { console.log(&#39;searching&#39;); },1000)); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; XMLHttpRequest常用方法： open(method, url, [async, user, password])初始化，async(false/true)控制同步/异步 send([body])发送请求 abort()中止请求 setRequestHeader(name, value)设置请求头 常用属性： status: 404/200… statusText: Not Found/OK… responseType: 响应格式 readyState： 状态 withCredentials: 跨域设置 UNSENT = 0; // 初始状态 OPENED = 1; // open 被调用 HEADERS_RECEIVED = 2; // 接收到 response header LOADING = 3; // 响应正在被加载（接收到一个数据包） DONE = 4; // 请求完成 常用监听事件： onload onerror onprogress 题目const a = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt); // 数组a中的&#39;1&#39;转化为10进制。 console.log(a); // [1, NaN, NaN] // map的三个参数(item,index,array) /* parseInt(string, radix) 当radix等于0或者undefined或者没有指定时，如果string以&#39;0x&#39;或者&#39;&#39;0X&#39;开头，则radix=16 以&#39;0&#39;开头，根据实际情况radix=10/8。 */ const users = [ { name: &#39;Alan&#39;, age: 19 }, { name: &#39;Bob&#39;, age: 25 } ]; const userList = users.sort((a, b) =&gt; b.age-a.age); // 根据年龄进行排序，注意：sort会改变原来的数组 function isSameLetter(a, b) { a = a.toString().toLowerCase(); b = b.toString().toLowerCase(); return a.split(&#39;&#39;).sort().join(&#39;&#39;) === b.split(&#39;&#39;).sort().join(&#39;&#39;); } console.log(isSameLetter(&#39;176as&#39;, &#39;a17s6&#39;)); //判断两者是否是由相同的字母组成，顺序可以不一样 CSStranslate和使用绝对定位的区别translate会占据原来的位置，绝对定位会脱离文档流。 BFC概念：很模糊抽象，是页面上一个隔离的独立容器 创建方式： 根元素 float不为none position: absolute/fixed display: inline-block/table-cell overflow不为visible 弹性盒子 选择器优先级!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 垂直居中&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; table-cell .outer { width: 400px; height: 400px; background: aqua; display: table-cell; vertical-align: middle; text-align: center; } .inner { width: 100px; height: 100px; background: brown; display: inline-block; } flex布局 绝对定位 已知子元素宽高未知子元素宽高margin.outer { position: relative; } .inner { position: absolute; left: 50%; top: 50%; margin-left: -50px; /* 宽度一半 */ margin-top: -50px; /* 高度一半 */ }.outer { position: relative; } .inner { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); }.outer { position: relative; } .inner { position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; } 网络从输入URL到页面加载发生了什么 浏览器查找当前URL是否存在缓存，并比较缓存是否过期 根据DNS解析得到IP地址 建立TCP连接（3次握手） HTTP发请求 服务器处理请求，返回数据 渲染页面，构建DOM树 关闭TCP连接（4次挥手） 常用状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 状态码 描述 200 请求成功 204 无内容。服务器成功处理，但未返回内容 301 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 304 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 400 客户端请求的语法错误，服务器无法理解 401 请求要求用户的身份认证 403 服务器理解请求客户端的请求，但是拒绝执行此请求 404 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 500 服务器内部错误，无法完成请求 网络七层协议引用网上的一张图，如侵权请联系我删除😂 引自维基百科TCP/IP协议族是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。这个协议族由互联网工程任务组负责维护。 TCP（Transmission Control Protocol 传输控制协议）:通过三次握手与服务器建立一个全双工的通信，在数据传送之前把数据分割成IP包，在到达服务器时再将他们重组。 IP（Internet Protocol 网际协议）:IP负责客户端与服务端之间的通信，IP负责在因特网上发送和接受数据包。通过IP，数据被分割成小的独立的包，然后通过互联网在计算机之间传送。 HTTPHTTP(HyperText Transfer Protocol)，基于TCP实现的应用层协议。HTTP是一个无状态的协议，即客户端和服务端之间不用建立持久的链接，当客户端发送一个请求，服务端返回响应时，连接就被关闭了。 当请求一个url时www.baidu.com，首先DNS解析出该地址对应的IP地址，然后将相关信息封装成一个HTTP请求数据包。然后TCP（三次握手）建立连接，连接成功后发送HTTP请求，服务端响应回来后，关闭TCP连接。如果浏览器或服务器在头部加入了Connection:keep-alive，那么TCP在发送完信息后仍然保存连接，这样可以减少TCP连接次数，能提升性能和服务器吞吐率。 缺点： 通行使用明文，不安全 不验证身份，可能遭遇伪装 无法验证报文完整性，可能遭遇篡改 前面提到了HTTP是一个无状态的协议，那如何让它拥有状态？ session和cookie cookie(key/value形式): 客户端返回cookie附在响应头中的Set-Cookie或者Set-Cookie2，cookie保存在客户端，下次访问时连同cookie发送给服务端 cookie的同源和跨域: cookie只关注域名，忽略协议和端口，意思是协议或者端口不同不属于跨域 session机制（服务端维护的），基于cookie工作： session和sessionId（返回给客户端） 当客户端访问服务端时，首先检查请求中是否包括sessionId。如果有，通过sessionId检索出对应session进行一系列操作。如果没有sessionId，创建一个session以此对应的sessionId通过cookie存在客户端，客户端之后访问服务端时通过这个sessionId维护HTTP状态。 HTTPSHTTPS = HTTP + TLS/SSL 经过加密的HTTP，更加安全，利用SSL/TLS加密数据包； TLS/SSL:安全传输层协议Transport Layer Security TSL/SSL涉及到三种算法： 散列函数Hash：MD5、SHA1、SHA256（函数单向不可逆，加密传输信息以及信息摘要） 对称加密：AES-CBC、DES、3DES、AES-GCM 非对称加密：RSA（分公钥和私钥） TSL工作方式： 首先使用非对称加密算法加密进行通信，服务端返回公钥并协商使用对称加密后的密钥对通信进行加密。 RSA存在的隐患： 无法确保服务器身份的合法性（因为公钥不包含服务器信息）： 例如： C（客户端）和S（服务端）通信时，H（劫持者）截获了S与C的通信，H将自己的公钥pub_H给了C，当C向S发送请求时，实际上是使用pub_H加密的，这样H就能获取到C发送的消息了。这样原本属于C和S的通信现在就变成了C和H的通行了。 解决方案：引入第三方认证机构，验证公钥拥有者的信息然后颁发证书，简称PKI体系 - S向第三方机构提交公钥和公司相关信息 - CA（即三方认证机构）通过一系列渠道验证审核S信息的正确性 - 审核通过后，CA向S签发证书，证书信息包括：S的公钥、S公司相关信息、签发机构CA的信息、有效时间、证书序列号（前面这些信息全是明文显示）。签名（使用散列函数计算公开的明文信息的信息摘要，然后用CA的私钥对信息摘要加密） - C向S发送请求，S返回证书 - C读取证书中的明文信息，采用相同的散列函数计算得到信息摘要，然后利用CA对应的公钥对签名进行解密，对比证书中的信息摘要来验证证书/公钥的合法性。跨域非同源请求，均为跨域。名词解释：同源 —— 如果两个页面拥有相同的协议（protocol），端口（port）和主机（host），那么这两个页面就属于同一个源（origin）。 jsonp: 通过script标签的src属性来实现 CORS: 服务端设置Access-Control-Allow-Origin和Access-Control-Allow-Credentials为true Vue设置跨域： vue.http.options.credentials = true Nginx代理 框架单页应用优缺点优点： 基于ajax加载数据，无需刷新页面，用户体验好 前后端分离，后端代码可以应用到多端 减轻服务器压力 缺点： 不利于SEO，可以使用SSR解决 首屏加载速度慢 不支持浏览器前进后退功能","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"面试造轮","slug":"前端/面试造轮","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%80%A0%E8%BD%AE/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://alanwang.site/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"webpack4.0进阶（一）","slug":"webpack4.0进阶（一）","date":"2020-05-25T06:43:46.000Z","updated":"2020-05-30T09:20:00.000Z","comments":true,"path":"2020/05/25/webpack4.0进阶（一）/","link":"","permalink":"https://alanwang.site/2020/05/25/webpack4.0%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"webpack4.0进阶学习","text":"webpack4.0进阶学习 Tree Shaking按需打包文件index.jsmoment.jsimport { used } from './moment'; used();export function used() { console.log('used function'); } export function notUsed() { console.log('notUsed funtion'); } 上面这个例子中我们只使用到了moment中的used，但是打包后连同notUsed一起被打包进了main.js文件中 Tree Shaking可以帮我们解决这个问题。 注意：1.Tree Shaking只在production模式下生效。2.只支持ES Module 语法（import），不支持CommonJs package.jsonwebpack.config.js\"sideEffects\": false, 或者 \"sideEffects\": [ \"**/*.css\", \"**/*.scss\", \"./esnext/index.js\", \"./esnext/configure.js\" ], 意思是对这些文件不进行tree shaking处理 例如 import './common.css'; 虽然我们没有使用common.css的一些东西，但是它起到了样式的作用的，如果不在sideEffect中设置的话，webpack是不会对它进行打包的。optimization: { usedExports: true, } // production模式是会自动配置好，可写可不写 开发环境和生产环境配置文件由于开发环境需要调试代码所以会引入devServer之类的插件，那么这部分插件在生产环境中是不需要使用到的，我们可以对开发环境和生产环境分别设置不同的配置文件。 首先安装插件webpack-merge用来将拼接common配置 npm i webpack-merge -D目录如下： webpacktest ├── package.json ├── src │ ├── index.html │ ├── index.js │ └── moment.js ├── webpack.common.js ├── webpack.dev.js └── webpack.prod.js {% tabs 3 %} ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const { CleanWebpackPlugin } = require('clean-webpack-plugin'); module.exports = { mode: 'development', // 默认为production entry: { main: './src/index.js', // 打包入口文件 }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 loader: 'babel-loader' }, { test: /\\.css$/, use: ['style-loader', 'css-loader'], }, ], }, output: { // 输出文件配置 filename: '[name].js', path: path.resolve(__dirname, 'dist'), }, optimization: { usedExports: true, }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', }), new CleanWebpackPlugin(), ], }; ``` ```js const merge = require('webpack-merge'); const commonConfig = require('./webpack.common.js'); const devConfig = { mode: 'development', // 默认为production devtool: 'cheap-module-eval-source-map', devServer: { contentBase: './dist', open: true, // 自动打开浏览器 port: 3001, // 服务器端口号 hot: true, // 开启HRM } }; module.exports = merge(commonConfig, devConfig); ``` ```js const merge = require('webpack-merge'); const commonConfig = require('./webpack.common.js'); const prodConfig = { mode: 'development', // 默认为production devtool: 'cheap-module-source-map' }; module.exports = merge(commonConfig, prodConfig); ``` ```js \"scripts\": { \"dev\": \"webpack-dev-server --config webpack.dev.js\", \"build\": \"webpack --config webpack.prod.js\" }, ``` {% endtabs%} 配置好后，开发环境使用npm run dev进行打包，生产环境用npm run build进行打包。 代码分割代码分割有利于性能的优化。何为代码分割： 有这么一个场景，我在index.js中使用到了一些公共代码库/工具库（lodash），index.js中的代码是依赖于lodash中的一些工具的。当我们打包时，lodash也是被打包到了main.js文件中，并且一旦index.js中的业务代码改变了，连同lodash也要一同重新打包加载，但是我们一般是不会去改动lodash这类工具库的。于是我们可以借助代码分割来将业务代码和lodash进行分割，这样下次再修改业务代码时，我们就无需重新加载lodash的内容了。 先安装lodash npm i lodash -S这里为了便于查看打包后的文件内容，我们加上一条npm script&quot;start&quot;: &quot;webpack --config webpack.dev.js&quot;(由于devServer不会生成打包内容) index.js import _ from &#39;lodash&#39;; console.log(_.compact([0, 1, false, 2, &#39;&#39;, 3])); npm run start打包，发现打包后的main.js文件中包含lodash内容。 那如何实现代码分割呢，只需配置webpack.common.js文件 optimization: { splitChunks: { chunks: &#39;all&#39; } } 再次打包，发现打包后的文件中多了一个vendor~main.js，webpack自动将lodash内容打包进去了，而main.js文件中就没有了lodash的内容了。 dist ├── index.html ├── main.js └── vendors~main.js 上面介绍的时同步代码分割，下面看一下异步代码分割index.js，可以实现懒加载 async function createElement() { const { default: _ } = await import(/* webpackChunkName: &quot;lodash&quot; */&#39;lodash&#39;); const element = document.createElement(&#39;div&#39;); element.innerHTML = _.compact([0, 1, false, 2, &#39;&#39;, 3]); return element; } document.addEventListener(&#39;click&#39;, () =&gt; { createElement().then(element =&gt; { document.body.appendChild(element); }) }) /* webpackChunkName: &quot;lodash&quot; */设置打包后的文件名为vendors~lodash.js，打开浏览器可以看到只有点击页面时，才会引入vendors~lodash.js，实现了懒加载。 打包后的目录 dist ├── index.html ├── main.js ├── vendors~lodash.js └── vendors~main.js当然可以通过其他配置来设置打包后的文件名称。 代码分割更多配置 打包分析工具首先要拿到status.json文件，具体获取方式只需配置npm script即可 &quot;start&quot;: &quot;webpack --profile --json &gt; status.json --config webpack.dev.js&quot;, 打包后会生成status.json文件。 然后使用官网提供的一些工具就可以可视化分析打包结果了。 在写代码时，我们要尽可能的使用异步引入，这样可以提高代码的使用率，提升性能，减少加载不必要的代码。 {% note info, 查看代码使用率的方法，浏览器控制台按下ctrl+shift+p，输入show coverage %} 代码优化现在有一个优化场景，我有一个登录按钮，当点击按钮后弹出登录框。这里的优化思路是，页面加载时只加载登录按钮的代码，当按钮代码加载完后。利用空闲时间去加载登录框的代码。这样既可以优化首屏加载速度，还可以解决因使用懒加载登录框（也就是点击按钮后再去加载）而带来的用户体验较差的问题。 具体代码：(只需要在import中加入/* webpackPrefetch: true */) {% tabs 1 %} ```js document.addEventListener('click', () => { import(/* webpackPrefetch: true */'./loginModal.js').then(({default: login}) => { login(); }) }) ``` ```js export default function () { alert('loginModal'); } ``` {% endtabs %} css文件处理MiniCssExtractPlugin This plugin should be used only on production builds without style-loader in the loaders chain, especially if you want to have HMR in development. 官方推荐不要在开发环境中使用，因为不支持HMR，不利于提高开发效率。 npm install --save-dev mini-css-extract-pluginindex.jsstyle.cssimport './style.css';body { background: #e65; } webpack.common.jswebpack.dev.jswebpack.prod.jspackage.jsonconst path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const { CleanWebpackPlugin } = require('clean-webpack-plugin'); module.exports = { mode: 'development', // 默认为production entry: { main: './src/index.js', // 打包入口文件 }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 loader: 'babel-loader', }, ], }, output: { // 输出文件配置 filename: '[name].js', chunkFilename: '[name].chunk.js', path: path.resolve(__dirname, 'dist'), }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', }), new CleanWebpackPlugin(), ], optimization: { usedExports: true, splitChunks: { chunks: 'all', }, }, };const merge = require('webpack-merge'); const commonConfig = require('./webpack.common.js'); const devConfig = { mode: 'development', devtool: 'cheap-module-eval-source-map', devServer: { contentBase: './dist', open: true, // 自动打开浏览器 port: 3001, // 服务器端口号 hot: true, // 开启HRM }, module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'], } ], }, }; module.exports = merge(commonConfig, devConfig);const merge = require('webpack-merge'); const commonConfig = require('./webpack.common.js'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const prodConfig = { mode: 'development', devtool: 'cheap-module-source-map', module: { rules: [ { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'], } ], }, plugins: [ new MiniCssExtractPlugin({}) ] }; module.exports = merge(commonConfig, prodConfig);\"sideEffects\": [ \"*.css\" ], 也可以使用optimize-css-assets-webpack-plugin来压缩css代码 配置output解决浏览器cache问题浏览器是有缓存功能的，在我们第一次加载main.js后，浏览器会保有main.js的缓存，下次再加载时就直接从缓存获取了。但是当我们下次发布新版本时（修改了main.js文件），浏览器还是使用以前缓存的main.js内容，所以显示的内容并不是最新的。 处理方法 设置output的filename，添加[contenthash]占位符。 output: { // 输出文件配置 filename: &#39;[name].[contenthash].js&#39;, chunkFilename: &#39;[name].[contenthash].js&#39;, }, shimming看一个场景，假设library.js是一个比较老的第三方库。 index.jslibrary.jsimport './style.css'; import { createText } from './library'; createText();// 这个第三方库中使用到了loadsh，但是并没有引入lodash export function createText() { document.getElementById('root').innerHTML = _.compact([0, 1, false, 2, '', 3]); } npm run dev打包后浏览器报错 Uncaught ReferenceError: _ is not defined 如果library.js是我们自己写的库那还好说，直接自己手动引入lodash就可以了。但是由于是第三方库，源文件是在node_module中的，不利于修改，这个时候就可以用shimming来解决了。 配置webpack.common.js // 记得引入const webpack =require(&#39;webpack&#39;); // 下面代码的意思：当遇到_时，会自动为我们添加下面代码 // import _ from &#39;lodash&#39; plugins: [ new webpack.ProvidePlugin({ _: &#39;lodash&#39; }) ], 更多配置参考shimming 细粒度 shimming 试着在index.js中打印出this，发现this其实是指向模块本身。那如何把this指向window呢，这里要借助imports-loader npm i imports-loader -D配置好loader rules: [ { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 use: [ { loader: &#39;babel-loader&#39;, }, { loader: &#39;imports-loader?this=&gt;window&#39; } ] }, ] 总结 Tree Shaking可以实现对js文件的按需打包，只在production下生效。 为生产和开发环境分别创建不同配置文件。 利用代码分割实现懒加载（利用魔法注释）。 利用status.json来分析打包过程。 单独生成css文件，减少mian.js体积。 为output文件设置hash值，防止浏览器使用缓存。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"记录生活2020/5","slug":"记录生活2020-5","date":"2020-05-22T14:50:26.000Z","updated":"2020-05-22T14:50:26.000Z","comments":true,"path":"2020/05/22/记录生活2020-5/","link":"","permalink":"https://alanwang.site/2020/05/22/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB2020-5/","excerpt":"这是一篇记录5月生活的个人随记。📝","text":"这是一篇记录5月生活的个人随记。📝 2020-05-22现在是22:53，我的论文初稿终于上传审核了🎈，查重率4.8%。记录一下，后天就要线上答辩了。","categories":[{"name":"记录生活","slug":"记录生活","permalink":"https://alanwang.site/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"},{"name":"2020","slug":"记录生活/2020","permalink":"https://alanwang.site/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/2020/"}],"tags":[{"name":"记录生活","slug":"记录生活","permalink":"https://alanwang.site/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"}]},{"title":"webpack4.0学习总结（四）","slug":"webpack4.0学习总结（四）","date":"2020-05-18T02:24:19.000Z","updated":"2020-05-20T07:19:00.000Z","comments":true,"path":"2020/05/18/webpack4.0学习总结（四）/","link":"","permalink":"https://alanwang.site/2020/05/18/webpack4.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"webpack的devServer热更新以及HMR局部热更新","text":"webpack的devServer热更新以及HMR局部热更新 DevServerDevServer可以起一个本地服务并且实现代码的热更新。可以省去我们每次更新代码后重启服务额操作。 npm i webpack-dev-server -D配置文件 {% tabs 1%} ```json \"scripts\": { \"build\": \"webpack\", \"start\": \"webpack-dev-server\" }, ``` ```js devServer: { contentBase: './dist', open: true, // 自动打开浏览器 port: 3001, // 服务器端口号 }, ``` {% endtabs %} 我们之后只需要使用npm run start就可以把服务跑起来了，之后只要改动代码就会自动更新了，开发效率提高了很多有没有😝 {% note link, devServer[更多配置内容](https://webpack.js.org/configuration/dev-server/#devserver) %} HMR实现局部热更新HMR（Hot Module Replacement） 当我们更改了部分文件后，我们发现webpack-dev-server帮我们重新渲染所有内容，假如我只改动了一小部分，只想更新这一部分内容就可以用了使用HMR来实现了。 说再多不如看一个例子 {% tabs 2%} ```js import './index.css'; var root = document.getElementById('root'); root.innerHTML = 'add new block'; document.getElementById('btn').onclick = function() { var newBlock = document.createElement('p'); newBlock.innerHTML = 'new Block'; root.append(newBlock); } ``` ```js p { width: 100px; } p:nth-child(6) { background: red; } ``` {% endtabs %} 这里例子就是点击按钮添加一个p元素，第6个p元素显示为红色背景 这个时候我觉得红色不好看，想换成黄色，修改，保存一气呵成。 结果webpack-dev-server给我全部重新渲染了，我还要再点6下才能看到效果，这里如果是1000（虽然不太可能）呢，那我岂不是要点1000下😱。 这个时候配置HRM就可以轻松解决这个问题了。 只需要再webpack.config.js中配置 devServer: { contentBase: &#39;./dist&#39;, // Tell the server where to serve content from open: true, // 自动打开浏览器 port: 3001, // 服务器端口号 hot: true, // 开启HRM }, 搞定😎，不过这里由于有css-loader帮我们做了一些更新的任务，所以我们并没有写过多的代码。那如果没有css-loader处理那怎么办？下面看一下具体配置。 index.jscounter.jsnumber.jsimport Counter from './counter' import Number from './number' Counter(); Number();function Counter() { var root = document.getElementById('root'); var counter = document.createElement('div'); counter.innerHTML = 0; counter.onclick = function () { counter.innerHTML = parseInt(counter.innerHTML, 10) + 1; } root.append(counter); } export default Counter;function Number() { var root = document.getElementById('root'); var data = document.createElement('div'); data.setAttribute('id', 'number'); data.innerHTML = '2000'; root.append(data); } export default Number; 可以看到当我一改变number，counter中的状态又重新渲染变成0了😩。 这里我们就要通过一部分代码来处理一下了（css-loader就是帮我们完成了这部分工作） import Counter from &#39;./counter&#39; import Number from &#39;./number&#39; Counter(); Number(); if (module.hot) { // 如果开启HMR module.hot.accept(&#39;./number.js&#39;, () =&gt; { var root = document.getElementById(&#39;root&#39;); root.removeChild(document.getElementById(&#39;number&#39;)); console.log(&#39;number is updated&#39;); Number(); // 一旦number.js文件改变，进行一系列处理 }) } HMR详细文档 处理ES6语法我们先用ES6写一些代码 const name = &#39;Alan&#39;; const list = [1, 8, 4, 6]; const resultList = list.filter(item =&gt; item &gt; 5); new Promise(() =&gt; { console.log(&#39;666&#39;); }) console.log(resultList); npm run build打包看一下chrome效果 奈何这个世界上还有IE这种东西😣，IE上看一下效果 可以看一下报错的地方： eval(&quot;const name = &#39;Alan&#39;;\\r\\nconst list = [1, 8, 4, 6];\\r\\n\\r\\nconst resultList = list.filter(item =&gt; item &gt; 5);\\r\\n\\r\\nnew Promise(() =&gt; {\\r\\n console.log(&#39;666&#39;);\\r\\n})\\r\\n\\r\\nconsole.log(resultList);\\r\\n\\n\\n//# sourceURL=webpack:///./src/index.js?&quot;); 看来IE是识别不了ES6语法的，那我们这里就要借助babel处理了。 npm install --save-dev babel-loader @babel/core @babel/preset-env @babel/preset-env把ES6转化为ES5 @babel/corebabel核心内容 配置webpack { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 loader: &#39;babel-loader&#39;, options: { presets: [&#39;@babel/preset-env&#39;] } }, 再打包看一看 打包后的index.js文件 var name = &#39;Alan&#39;; var list = [1, 8, 4, 6]; var resultList = list.filter(function (item) { return item &gt; 5; }); new Promise(function () { console.log(&#39;666&#39;); }); console.log(resultList); 虽然处理了一些ES6语法（箭头函数，const），但是像filter和Promise还是没有处理的。 这里就要使用@babel-polyfill，它会模拟一个ES5环境 npm install --save @babel/polyfill安装后在文件开头引入就可以了 import &#39;@babel/polyfill&#39;; const name = &#39;Alan&#39;; const list = [1, 8, 4, 6]; const resultList = list.filter(item =&gt; item &gt; 5); new Promise(() =&gt; { console.log(&#39;666&#39;); }) console.log(resultList); 再次打包运行 虽然效果完成了，但是对比一下没使用@babel/polyfill和使用了@babel/polyfill打包后的大小😮 就引入了一个@babel-polyfill，体积就增加了这么多？ 其实是因为@babel-polyfill模拟了所有的ES5环境，而我们这里只使用了Promise和filter，所以我们可以通过配置useBuiltIns让它只模拟我们使用到的。 配置了useBuiltIns后，它是会自动帮我们引入@babel/polyfill所以这里我们无需再引入。 { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 loader: &#39;babel-loader&#39;, options: { presets: [[&#39;@babel/preset-env&#39;, { useBuiltIns: &#39;usage&#39; }]] } }, main.js 68.6 KiB main [emitted] main 再看一下打包后的文件小了很多有没有？ babel的配置是可以单独放在.babelrc文件中的，直接将options中的内容放到.babelrc目录下即可 { &quot;presets&quot;: [[&quot;@babel/preset-env&quot;, { &quot;useBuiltIns&quot;: &quot;usage&quot; }]] } 使用@babel/preset-react打包React文件npm install --save-dev @babel/preset-react.babelrcindex.js{ \"presets\": [[\"@babel/preset-env\", { \"useBuiltIns\": \"usage\" }], \"@babel/preset-react\" ] }import React, { Component } from 'react'; import ReactDom from 'react-dom'; class App extends Component { render() { return ( &lt;div&gt;Hello React&lt;/div&gt; ); } } ReactDom.render(&lt;App /&gt;, document.getElementById('root')); 这里有一点需要注意一下，presets顺序是从后往前的，和css-loader一样，也就是js文件是先被@babel/preset-react处理的再被@babel/preset-env处理的。 总结使用的babel@babel/preset-react处理react的jsx语法 @babel-polyfill处理低版本浏览器无法处理的语法，类似Promise、Array.from、Object.assign @babel/preset-env把ES6转化为ES5 @babel/corebabel核心内容 useBuiltIns:usage按需引入 更多配置参考babel官网","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"webpack4.0学习总结（三）","slug":"webpack4.0学习总结（三）","date":"2020-05-17T02:05:14.000Z","updated":"2020-05-16T05:33:00.000Z","comments":true,"path":"2020/05/17/webpack4.0学习总结（三）/","link":"","permalink":"https://alanwang.site/2020/05/17/webpack4.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"这节介绍了webpack一些常用的plugins的使用","text":"这节介绍了webpack一些常用的plugins的使用 我的总结篇的第一节中提到了index.html是需要我们手动移动到打包后的dist目录下的，那我比较懒能不能让webpack来帮我完成呢。🤔 这个时候plugins就派上了用场。 html-webpack-plugin The HtmlWebpackPlugin simplifies creation of HTML files to serve your webpack bundles. This is especially useful for webpack bundles that include a hash in the filename which changes every compilation. You can either let the plugin generate an HTML file for you, supply your own template using lodash templates, or use your own loader. 官网介绍到，它可以帮我们自动创造HTML文件，并且还可以使用自定义的HTML模板。 直接看例子： npm i html-webpack-plugin -D webpacktest ├── package-lock.json ├── package.json ├── src │ └── index.js └── webpack.config.js {% tabs 1 %} ```js var root = document.getElementById('root'); root.innerHTML = 'Hello Webpack' ``` ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { mode: 'development', // 默认为production entry: { main: './src/index.js', // 打包入口文件 }, output: { // 输出文件配置 filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), }, plugins: [new HtmlWebpackPlugin()] }; ``` {% endtabs %} npm run build进行打包看下结果 webpacktest ├── dist │ ├── bundle.js │ └── index.html ├── package-lock.json ├── package.json ├── src │ └── index.js └── webpack.config.js HtmlWebpackPlugin插件自动为我们生成了index.html，但是…浏览器打开index.html一看什么都没有。这是咋回事，来看一看生成的index.html文件发现了问题 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Webpack App&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;/head&gt; &lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 生成的文件中是没有#root节点的，那怎么办？我们还需要配置一下HtmlWebpackPlugin，前面官网的介绍中也提到了 You can either let the plugin generate an HTML file for you, supply your own template using lodash templates, or use your own loader 我们需要自己提供一个HTML模板，于是在src目录下创建一个index.html作为HtmlWebpackPlugin打包的模板 index.htmlwebpack.config.js&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;html template&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;plugins: [new HtmlWebpackPlugin({ template: './src/index.html' })] 再打包一次看一下dist目录下生成的index.html文件和我们定义的html模板是一样的了。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;html template&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 打开浏览器发现Hello Webpack也正确显示出来了。🎉 clean-webpack-pluginhttps://www.npmjs.com/package/clean-webpack-plugin 它的作用就是在每次打包前会将webpack中配置的out.path(dist目录)清空 npm i clean-webpack-plugin -D为了验证是否清空了dist目录，我们先在dist目录下自己创建一个文件my.js dist ├── bundle.js ├── index.html └── my.js const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;); module.exports = { mode: &#39;development&#39;, // 默认为production entry: { main: &#39;./src/index.js&#39;, // 打包入口文件 }, output: { // 输出文件配置 filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;), }, plugins: [new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39; }), new CleanWebpackPlugin()] }; npm run build打包 dist ├── bundle.js └── index.html 我们发现之前创建的my.js文件已经被CleanWebpackPlugin给清除了。 多入口文件有时我们的打包入口文件有多个，这时候就要通过设置entry来完成打包。并通过[name]占位符来设置打包出来的文件的名称。 const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;); module.exports = { mode: &#39;development&#39;, // 默认为production entry: { main: &#39;./src/index.js&#39;, // 打包入口文件 enrty: &#39;./src/entry.js&#39;, }, output: { // 输出文件配置 filename: &#39;[name].js&#39;, path: path.resolve(__dirname, &#39;dist&#39;), }, plugins: [new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39; }), new CleanWebpackPlugin()] }; npm run build打包结果 dist ├── enrty.js ├── index.html └── main.js 看一看index.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;html template&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;enrty.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 可以看到HtmlWebpackPlugin帮我们把main.js和entry.j2个文件都自动引入到html文件当中了。 在实际业务场景中，为了优化服务器性能，我们会将打包好的dist目录中的一部分文件丢到cdn中来加快访问速度。这时候我们就要将cdn的地址手动复制到打包后的html文件中了，不过我们可以通过设置output的publicPath来完成。 output: { // 输出文件配置 filename: &#39;[name].js&#39;, publicPath: &#39;https://cdn.example.com/assets&#39;, path: path.resolve(__dirname, &#39;dist&#39;), }, 打包后的效果 &lt;script src=&quot;https://cdn.example.com/assets/main.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.example.com/assets/enrty.js&quot;&gt;&lt;/script&gt; SourceMapsourcemap是什么，我们修改一下index.js文件内容并且在webpack配置中关闭sourcemap(devtool: ‘none’) {% tabs 3 %} ```js var root = document.getElementById('root'); errfun(); root.innerHTML = 'Hello Webpack' ``` ```js const path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const { CleanWebpackPlugin } = require('clean-webpack-plugin'); module.exports = { mode: 'development', // 默认为production devtool: 'none', entry: { main: './src/index.js', // 打包入口文件 enrty: './src/entry.js', }, output: { // 输出文件配置 filename: '[name].js', path: path.resolve(__dirname, 'dist'), }, plugins: [new HtmlWebpackPlugin({ template: './src/index.html' }), new CleanWebpackPlugin()] }; ``` {% endtabs %} index.js中使用了一个不存在的函数errfun()，打包运行一下是会报错的。 这个时候我们想要调试代码，但是它这里提示的错误行是打包后的main.js所在的位置。 现在我们配置sourcemap看看。 devtool: &#39;source-map&#39;, 这个时候我们就能定位到错误是出现在我们index.js的第三行了。 配置不同sourceMap会不同程度上增加应用的打包时间或消耗性能 官网提供了多种sourceMap配置，不同sourceMap打包消耗时间不同，详情。 sourcemap其实就是main.js和index.js之间的一种映射关系，在代码存在错误时，它能根据映射关系找到index.js中的错误所在处，有利于我们debug代码。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"Hexo博客定制","slug":"Hexo博客定制","date":"2020-05-16T08:02:54.891Z","updated":"2020-05-16T08:02:54.891Z","comments":true,"path":"2020/05/16/Hexo博客定制/","link":"","permalink":"https://alanwang.site/2020/05/16/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%9A%E5%88%B6/","excerpt":"介绍了评论系统以及一些自定义配置","text":"介绍了评论系统以及一些自定义配置 评论系统注册一个LeanCloud国际版账号（国内的好像需要绑定域名和备案）注册地址👉https://console.leancloud.app/login.html#/signup 之后创建一个应用，名字随便取 在设置中找到应用keys,把appid和appkey复制到hexo对应的配置当中。由于本文重点讲邮件回复功能，这一部分就不多过赘述了😝。直接进入正题。 修改邮件模板 &lt;p&gt;Hi, {{username}}&lt;/p&gt; &lt;p&gt; 你在 {{appname}} 的评论收到了新的回复，请点击查看： &lt;/p&gt; &lt;p&gt;&lt;a href=&quot;https://alanwang.site&quot; style=&quot;display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;&quot;&gt;马上查看&lt;/a&gt;&lt;/p&gt; 部署valine-admin首先进行配置 更多配置参考：https://github.com/DesertsP/Valine-Admin https://github.com/DesertsP/Valine-Admin.git网上的zhaojun1998版本我之前也试过，但是在国际版部署是会报错的，看错误信息应该是node版本太低了，而且就算部署成功了，后台也是登录不了的。这个版本我实测是没有问题的。 部署分支默认为master 点击部署即可 点击该链接访问后台管理系统（这里需要用户名和密码登录，需要到存储中的_User中自行创建） 这里只需要填写username、password、email即可，添加后在后台管理系统输入邮箱和密码就可以成功登录了。 设置定时唤醒 0 */30 7-23 * * ? 添加百度统计完成以下操作 注册百度统计账号 复制统计代码 将代码粘贴到G:\\blog\\themes\\volantis\\layout\\_partial下的footer.ejs 配置G:\\blog\\_config.yml baidu_analytics_key: 上面图片中的key值 查看是否配置成功 直接使用官网的代码检查就可以，如果没有用可以使用下面这种方法。 在控制台network中查看自己的网站是否有hm开头的请求，有就代表了成功了，大概20分钟后就可以在百度统计中看到数据了。 使用hexo-admin管理安装hexo-admin npm i hexo-admin -S运行命令 hexo s -d通过localhost:4000/admin访问即可如需使用hexo-admin中的deploy，只需在_config.yml中配置 admin: deployCommand: &#39;./hexo-deploy.sh&#39;","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://alanwang.site/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://alanwang.site/tags/Hexo/"},{"name":"Valine","slug":"Valine","permalink":"https://alanwang.site/tags/Valine/"},{"name":"评论系统","slug":"评论系统","permalink":"https://alanwang.site/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"name":"DIY博客","slug":"DIY博客","permalink":"https://alanwang.site/tags/DIY%E5%8D%9A%E5%AE%A2/"}]},{"title":"webpack4.0学习总结（二）","slug":"webpack4.0学习总结（二）","date":"2020-05-15T12:00:22.000Z","updated":"2020-05-16T05:33:00.000Z","comments":true,"path":"2020/05/15/webpack4.0学习总结（二）/","link":"","permalink":"https://alanwang.site/2020/05/15/webpack4.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"这节主要讲一讲一些常见的Loder的使用。包括file-loader、url-loader以及css-loader和style-loader。","text":"这节主要讲一讲一些常见的Loder的使用。包括file-loader、url-loader以及css-loader和style-loader。 Loaderfile-loader上一节简单介绍了webpack是什么，webpack是一个模块打包器，可以将es的模块文件进行打包。上一节我们只打包了js文件，那我们能不能打包其他类型的文件呢，先来试一试打包图片吧。 这里使用到了file-loader npm i file-loader -D{% tabs 1 %} ```js // ES Moudule 模块化引入 import ComponentB from './componentB'; var root = document.getElementById('root'); // CommonJs 模块引入 var ComponentA = require('./componentA'); var img1 = require('./IMG_3294.jpg'); console.log(img1); var img = new Image(); img.src = img1; root.append(img); new ComponentA(); new ComponentB(); ``` ```js const path = require('path'); module.exports = { mode: 'development', // 默认为production entry: { main: './src/index.js' // 打包入口文件 }, module: { rules: [ { test: /\\.jpg$/, use: { loader: 'file-loader' } } ] }, output: { // 输出文件配置 filename: 'bundle.js', path: path.resolve(__dirname, 'dist') } } ``` {% endtabs %} npm run build进行打包，我们看一下控制台打印出来的img1 这里可以看到img1是一个Module。 我们可以通过img1.default来获取路径或者直接通过import形式来引入，这样图片就成功得显示出来了😄 import img1 from &#39;./IMG_3294.jpg&#39; 通过这个例子可以知道了loader的大致作用方法了，通过test来匹配特定文件使用（use)特定的loader来对文件进行打包处理。 我们再看一下打包出来的文件 dist ├── a2099657cfcaf9f019ccf08e9dc8747d.jpg ├── bundle.js └── index.html 发现我们的图片名称被改变成了一长串字符，那我怎么让它不改变名字呢。这时候loader的options就派上用场了😎 rules: [ { test: /\\.(jpg|png)$/, use: { loader: &#39;file-loader&#39;, options: { name: &#39;[name].[ext]&#39; } } } ] 这里的[name]和[ext]是loader中的placeholder,分别表示文件的名字和后缀名，当然loader中还有很多的placeholder。 设置好后进行打包得到如下结果 dist ├── bundle.js ├── IMG_3294.jpg └── index.html 现在有一个问题，当我们的图片一旦多起来那全部打包放在根目录下拿岂不是很乱，这个时候就可以使用options中的output来规定经过loader处理后的输出路径了。 options: { name: &#39;[name].[ext]&#39;, outputPath: &#39;images/&#39; } 打包看一下结果成功👌，运行一下html文件图片也可以正常显示。 dist ├── bundle.js ├── images │ └── IMG_3294.jpg └── index.html 到这里我们就了解了file-loader的基本使用了。 url-loaderurl-loader也可以打包文件，但是和file-loader不同的是，它会将我们的图片转化成base64编码，那如果我不想转化呢，我们可以使用options中的limit属性来限制文件在小于多少时转化成base64编码，一旦大于这个值打包出来的效果就和file-loader一样了。 看一下例子就清楚了 npm i url-loader -D这里准备两个图片，一个大小300k，一个大小7k webpack配置 const path = require(&#39;path&#39;); module.exports = { mode: &#39;development&#39;, // 默认为production entry: { main: &#39;./src/index.js&#39; // 打包入口文件 }, module: { rules: [ { test: /\\.(jpg|png)$/, use: { loader: &#39;url-loader&#39;, options: { name: &#39;[name].[ext]&#39;, outputPath: &#39;images/&#39;, limit: 10240 } } } ] }, output: { // 输出文件配置 filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) } } 看一下打包后的文件 dist ├── bundle.js ├── images │ └── 300k.jpg └── index.html 结果是大于10240的300k.jpg文件被以图片形式打包出来了，那7k.jpg文件去哪了呢，我们在bundle.js文件中可以找到了它，它被转化成了base64编码。 data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD...当然limit也可以设置为true/false，更多配置 我在操作中发现了如果html中没有使用到7k.jpg，url-loader是不会对它进行打包的。 {% note info, 这里并不建议把大文件转化为base64，这样会增加bundle.js的体积，对项目优化不太友好 %} 样式文件接着上面的例子，我现在想要为页面中的图片添加一些样式 {% tabs 2 %} ```js // ES Moudule 模块化引入 import ComponentB from './componentB'; import './index.css'; var root = document.getElementById('root'); // CommonJs 模块引入 var ComponentA = require('./componentA'); import img1 from './300k.jpg'; console.log(img1); var img = new Image(); img.src = img1; img.classList.add('circle'); root.append(img); new ComponentA(); new ComponentB(); ``` ```css .circle { width: 100px; height: 100px; border-radius: 50px; } ``` {% endtabs%} 现在我想要打包css文件该怎么办呢😶，我们要用到两个loader，css-loader和style-loader 安装 npm i style-loader css-loader -Dwebpack配置 { test: /\\.css$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] } 打包成功，打开网页看一看效果生效了 这里简单介绍一下style-loader和css-loader的作用，首先它们执行有先后顺序的，先使用css-loader对css文件进行打包，再用style-loader把打包后的css文件内容以&lt;style&gt;&lt;/style&gt;加到页面的header中。 有时候我们要为css加上浏览器引擎前缀-webkit，这里有一个loader可以帮我们完成postcss-loader 安装 npm i postcss-loader autoprefixer -Dwebpack配置 { test: /\\.css$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, { loader: &#39;postcss-loader&#39;, options: { ident: &#39;postcss&#39;, pulgins: [ require(&#39;autoprefixer&#39;) ] } }], }, 这里貌似有点问题，后期我再研究研究。 扩展css模块化先看一个场景 index.jscomponentA.jsimport './index.css'; import img1 from './300k.jpg'; import ComponentA from './componentA'; var root = document.getElementById('root'); var img = new Image(); img.src = img1; img.classList.add('circle'); root.append(img); ComponentA();import img1 from './300k.jpg'; function ComponentA() { var img = new Image(); img.src = img1; img.classList.add('circle'); var root = document.getElementById('root'); root.append(img); } export default ComponentA; 我们看到circle样式同样作用在了componentA上了，也就是说circle已经等同于是全局样式了😥。还好我们可以通过配置css-loader的options来使用css的模块化来解决这个问题。 { test: /\\.css$/, use: [ &#39;style-loader&#39;, { loader: &#39;css-loader&#39;, options: { modules: true, } }, { loader: &#39;postcss-loader&#39;, options: { ident: &#39;postcss&#39;, pulgins: [require(&#39;autoprefixer&#39;)], }, }, ], }, 配置好后我们在要使用样式的地方使用下面这种写法 import circle from &#39;./index.css&#39;; img.classList.add(circle.circle); 这样我们再修改样式就不会影响到其他地方了。 css外部引入这里主要介绍css-loader的optionsimportLoaders。 我们在index.css文件中引入外部css文件 @import &#39;./import.css&#39;; 假设我们有以下几个loader处理css文件 [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;, &#39;postcss-loader&#39;] 当webpack处理index.css文件时按照postcss-loader-&gt;sass-loader-&gt;css-loader顺序来执行css文件的 当遇到@import时处理import.css时，如果不做处理的话，import.css将直接从css-loader开始处理的，那我想让它从postcss-loader从头处理的话就要设置imortLoaders数目了。 { loader: &#39;css-loader&#39;, options: { importLoaders: 1, } }, 这里的1表示处理@import引入的css文件是，先要被前面的1个loader处理，也就是import.css的处理顺序是sass-loader-&gt;css-loader-style-loader。 处理字体文件直接使用file-loader处理就可以了 webpack.config.jsindex.jsiconfont.css{ test: /\\.(eot|ttf|svg|woff)$/, use: { loader: 'file-loader', }, },import './font/iconfont.css'; var root = document.getElementById('root'); root.innerHTML = '&lt;div class=\"iconfont icon-smile\"&gt;&lt;/div&gt;'@font-face {font-family: \"iconfont\"; src: url('iconfont.eot?t=1589604469136'); /* IE9 */ src: url('iconfont.eot?t=1589604469136#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('data:application/x-font-woff2;charset=utf-8;base64,这里base64代码太长删除掉了') format('woff2'), url('iconfont.woff?t=1589604469136') format('woff'), url('iconfont.ttf?t=1589604469136') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url('iconfont.svg?t=1589604469136#iconfont') format('svg'); /* iOS 4.1- */ } .iconfont { font-family: \"iconfont\" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } .icon-smile:before { content: \"\\e783\"; } ok!这章到此介绍。现在我们已经能够处理一些常见文件的打包了，对webpack的认识也应该算一个简单的入门了。😁","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"webpack4.0学习总结（一）","slug":"webpack4.0学习总结（一）","date":"2020-05-14T08:01:46.000Z","updated":"2020-05-14T08:01:46.000Z","comments":true,"path":"2020/05/14/webpack4.0学习总结（一）/","link":"","permalink":"https://alanwang.site/2020/05/14/webpack4.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"这一篇文章主要简单介绍了webpack是什么以及webpack的一些简单配置，你只要跟着我敲完这些代码后一定会对webpack有一个基本的了解的。😎","text":"这一篇文章主要简单介绍了webpack是什么以及webpack的一些简单配置，你只要跟着我敲完这些代码后一定会对webpack有一个基本的了解的。😎 webpack是一个模块打包器 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 上面引用了webpack官网的一段介绍，我们可以简单的理解webpack是一个模块打包器，那什么是模块打包器呢？😂先看一个简单的例子 index.htmlindex.jscomponentA.jscomponentB.js&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;// ES Moudule 模块化引入 import ComponentB from './componentB'; var root = document.getElementById('root'); // CommonJs 模块引入 var ComponentA = require('./componentA'); new ComponentA(); new ComponentB(); function ComponentA() { var componentA = document.createElement('div'); componentA.innerHTML = 'ComponentA'; root.append(componentA); } module.exports = ComponentA;function ComponentB() { var componentB = document.createElement('div'); componentB.innerHTML = 'ComponentB'; root.append(componentB); } export default ComponentB; 这里的模块可以理解成componentA和componentB，这种写法在vue和react中非常常见，写完这些文件后打开index.html文件，浏览器是会报错的。 Uncaught SyntaxError: Cannot use import statement outside a module 这是由于这里使用了es6中的模板引入的方式，浏览器是识别不了这种方式的，那怎么办呢？😥 这个时候webpack就派上用场了，首先初始化该项目 npm init -y初始化后会生成package.json文件 安装webpack-cli和webpack（不建议全局安装） npm install webpack-cli -D npm install webpack -S安装固定版本的webpack npm install webpack@版本号 npm info webpack // 查看包信息打包index.js npx webpack index.js{% note idea green, 这里如果不使用npx的话node会默认在全局环境中找寻webpack，加上npx的话就会使用项目中安装的webpack来执行命令 %} 打包后可以看到根目录下多了一个dist文件夹（webpack默认设置好的，后面会讲如何改变），里面有一个main.js文件，这个文件就是经过webpack处理后的index.js。 然后我们修改一下index.html的代码 &lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt; 这下浏览器就能正常识别html中的js文件了，到这里为止理解webpack是一个模块打包器应该不是很难了吧。webpack将模块componentA和componentB打包生成了最后的main.js。 webpack配置文件webpack的配置文件名默认是webpack.config.js，当然我们也可以指定配置文件。 开始之前我们先修改一下项目目录 webpacktest ├── index.html ├── package-lock.json ├── package.json ├── src │ ├── componentA.js │ ├── componentB.js │ └── index.js └── webpack.config.js 在项目根目录下新建配置文件webpack.config.js： const path = require(&#39;path&#39;); module.exports = { mode: &#39;development&#39;, // 默认为production entry: { main: &#39;./src/index.js&#39; // 打包入口文件 }, output: { // 输出文件配置 filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) } } 上面引用的path是node中的一个模块，__dirname表示webpack.config.js所在的目录。 entry可以简写为entry: ‘./src/index.js’ mode中的development和production有什么区别呢 我们看一下打包出来的文件bundle.js就知道了，production模式下的代码是一整行的，体积更小。而development模式下的代码不是一整行的有利于调试。 node path的 更多 执行下面命令后即可完成打包，效果和上一节一样 npx webpack当然也可以使用自定义配置文件 npx webpack --config 自定义配置文件写过项目的小伙伴应该都发现平时都是使用npm run xxx来打包项目的，下面就来介绍一下如何配置 修改package.json文件中的script &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot; }, 这样就可以通过npm run build来进行打包了，不过看过第一节的小伙伴肯定有疑问了，这样配置会不会使用全局的webpack去进行打包呢🙄，其实并不会，这里npm script命令会在项目的node_modules文件中去寻找webpack并执行。 打包好后我们打开index.html看看，发现是会报错的，这里注意：我们要手动把index.html移动到dist目录下并修改一下js路径，因为webpack并没有将index.html打包到dist目录下。 &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt; 这下再运行index.html就没有任何问题了。🎉","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"react博客-egg-jwt实现登录系统","slug":"react博客-egg-jwt实现登录系统","date":"2020-05-13T08:11:11.000Z","updated":"2020-05-13T08:11:11.000Z","comments":true,"path":"2020/05/13/react博客-egg-jwt实现登录系统/","link":"","permalink":"https://alanwang.site/2020/05/13/react%E5%8D%9A%E5%AE%A2-egg-jwt%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/","excerpt":"react博客系列文章","text":"react博客系列文章 何为jwtegg-jwt安装egg-jwtyarn add egg-jwt 配置egg-jwt 配置config/plugin.js文件 exports.jwt = { enable: true, package: &#39;egg-jwt&#39;, }; 配置config/config.default.js文件 // 自己设定的密钥，用于对信息进行签名 config.jwt = { secret: &#39;xxxxxx&#39;, }; 实例后台实现登录操作返回token 路由层 在第二个参数上加上jwt即可实现对该路由的鉴权 下面的jwt是自定义的中间件auth.js，该文件在下一部分介绍 &#39;use strict&#39;; /** * @param {Egg.Application} app - egg application */ module.exports = app =&gt; { const { router, controller, middleware, config } = app; const { admin } = controller.admin; const jwt = middleware.auth(config.jwt); router.post(&#39;/admin/login&#39;, admin.login); // 需要鉴权的路由再第二个参数上加上jwt router.get(&#39;/admin/get_type_list&#39;, jwt, admin.getTypeList); }; controller层 使用jwt.sign(加密数据, 密钥, [options, callback]) 来生成token 相关配置可以查看jsonwebtoken async login() { const { app, ctx } = this; const { username, password } = ctx.request.body; const checkValidate = await ctx.service.admin.admin.checkUserValidate(username, password); if (checkValidate) { // 将信息使用jwt进行签名加密生成token，expiresIn（token有效时间） const token = app.jwt.sign({ username, password }, app.config.jwt.secret, { expiresIn: &#39;2h&#39; }); ctx.body = { code: &#39;0001&#39;, msg: &#39;登录成功&#39;, token, }; } else { ctx.body = { code: &#39;0002&#39;, msg: &#39;用户名或者密码错误，请重试！&#39;, }; } } service层 async checkUserValidate(username, password) { const isValidate = await this.app.mysql.get(&#39;admin&#39;, { username, password }); return !!isValidate; } 使用postman进行测试 将生成的token返回给前台后使用localStorage.setItem把token保存到本地 前台传递token进行鉴权封装axios新建axios文件对axio进行封装，通过axios的拦截器来实现每次请求时自动在headers上携带token数据到后台，后台使用jwt.verify来检验token的正确性 axios.js import axios from &#39;axios&#39;; axios.interceptors.request.use(config =&gt; { // 登录成功后保存在本地的token const token = localStorage.getItem(&#39;token&#39;); config.headers.Authorization = `Bearer ${token}`; return config; }); axios.interceptors.response.use(response =&gt; { // code是后台接口设置的 const { code } = response.data; if (code === &#39;0003&#39; || code === &#39;0004&#39;) { window.location.href = &#39;/login&#39;; } return response; }); export default axios; 封装好后，之后都使用该封装好后的axios进行请求。 后台校验处理auth.js &#39;use strict&#39;; module.exports = options =&gt; { return async function auth(ctx, next) { // 获取前台通过axios封装后穿过来的token const token = ctx.header.authorization; if (token) { try { // 验证并对token进行解码 const decode = ctx.app.jwt.verify(token.split(&#39; &#39;)[1], options.secret); console.log(decode); await next(); } catch (error) { console.log(error.name); if (error.name === &#39;JsonWebTokenError&#39; || error.name === &#39;TokenExpiredError&#39;) { // 这里的错误有许多种情况：1.token错误，2.token过期... 这里统一处理为鉴权失败 ctx.body = { code: &#39;0003&#39;, msg: &#39;用户鉴权失败，请重新登录&#39;, }; } else { throw error; } } } else { ctx.body = { code: &#39;0004&#39;, msg: &#39;您没有登录，请先登录&#39;, }; } }; }; 后台通过/middleware/auth.js中间件来实现给需要鉴权的接口进行鉴权，通过对前台传过来的token数据进行验证jwt.verify来识别登录状态。对JsonWebTokenError错误统一处理，应为auth.js作为中间件，所以接口中出现的其他错误也会在这里被catch到，对于不是JsonWebTokenError的错误，直接把错误抛出去。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"},{"name":"ReactHook","slug":"ReactHook","permalink":"https://alanwang.site/tags/ReactHook/"},{"name":"jwt","slug":"jwt","permalink":"https://alanwang.site/tags/jwt/"}]},{"title":"react博客-项目部署","slug":"react博客-项目部署","date":"2020-05-13T07:51:16.000Z","updated":"2020-05-13T07:51:16.000Z","comments":true,"path":"2020/05/13/react博客-项目部署/","link":"","permalink":"https://alanwang.site/2020/05/13/react%E5%8D%9A%E5%AE%A2-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/","excerpt":"阿里云最近推出了一个“在家实践活动”，免费领取半年的服务器，真香。领取地址","text":"阿里云最近推出了一个“在家实践活动”，免费领取半年的服务器，真香。领取地址 购买阿里云服务器购买完成后会得到一个公网ip 下载软件putty来连接我们刚才购买的服务器，只需输入公网ip点击open即可 在命令行中输入用户名root和密码得到Welcome to Alibaba Cloud Elastic Compute Service !即完成了连接。 使用宝塔进行管理https://www.bt.cn/bbs/thread-19376-1-1.html 连接成功服务器后在命令行输入(Centos系统，其他系统查看上面网址)，复制按下鼠标右键完成宝塔的安装 yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh安装成功后会返回一个端口号为8888的网站以及账号和密码： 访问该地址，这个时候网站时不能访问的，因为远程服务器没有开放8888端口。 设置教程： https://www.bt.cn/bbs/thread-2897-1-1.html 登录成功后安装mysql和nginx（之后几乎所有的操作都在宝塔上进行） 需要安装软件 php环境（用于phpmyadmin） phpMyAdmin（用于管理mysql数据库） PM2（自带node环境） nginx 开放80(http)端口访问服务器在阿里云服务器管理控制台安全组中设置 设置后就可以通过公网ip访问服务器了 部署项目切换镜像源安装nrm（用来管理npm镜像源的工具）npm install -g nrm 常用命令 nrm ls 查看所有源地址 nrm use taobao 切换为淘宝镜像源 nrm add [name] [url] 添加源地址 通过git克隆代码到服务器把代码clone到服务器 打包项目并且部署 部署前台页面（next.js） yarn build yarn start 或者用PM2进行进程守护（待研究） 部署后台接口（egg.js） npm start 部署后台管理系统 直接npm build然后使用nginx进行代理 导入mysql数据出错在导入本地mysql文件时遇到了一些错误，参考文章： https://www.jianshu.com/p/788dceb93eff Linux查看端口号占用情况以及杀进程命令 netstart -anp（查看端口占用情况） lsof -i:8080（查看8080端口占用情况） kill -9 1234（杀PID=1234进程）","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"部署","slug":"部署","permalink":"https://alanwang.site/tags/%E9%83%A8%E7%BD%B2/"},{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"},{"name":"阿里云","slug":"阿里云","permalink":"https://alanwang.site/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}]},{"title":"测试主题","slug":"test1","date":"2020-05-13T01:19:17.000Z","updated":"2020-05-13T07:19:17.000Z","comments":true,"path":"2020/05/13/test1/","link":"","permalink":"https://alanwang.site/2020/05/13/test1/","excerpt":"这里是摘要","text":"这里是摘要 这里是正文 title: 测试主题 date: 2020-05-13 09:19:17 top: true categories: 测试分类 tags: 测试标签 author: name: 测试作者 avatar: https://gitee.com/alannum3/MyImages/raw/master/img/20200508165134.png music: # 文章音乐 server: netease # netease, tencent, kugou, xiami, baidu type: song # song, playlist, album, search, artist id: 16846091 thumbnail: # 文章缩略图 https://gitee.com/alannum3/MyImages/raw/master/img/20200508165134.png # 归档页面对应文章图标 icons: [fas fa-fire red, fas fa-star green] meta: # 文章底部按钮 footer: [btns] btns: repo: https://github.com/xaoxuu/hexo-theme-volantis bug: https://github.com/xaoxuu/hexo-theme-volantis/issues/ doubt: https://github.com/xaoxuu/hexo-theme-volantis/issues/ idea: https://github.com/xaoxuu/hexo-theme-volantis/issues/ cover: false #是否显示封面图 h1h2h3代码块tab1tab2这里面写内容，支持的语法格式有限，请尽量不要写太过复杂的东西。","categories":[{"name":"测试分类","slug":"测试分类","permalink":"https://alanwang.site/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"测试标签","slug":"测试标签","permalink":"https://alanwang.site/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"}]},{"title":"Typora+PicGo+Gitee（书写博客神器）","slug":"Typora-PicGo-Gitee（书写博客神器）","date":"2020-05-12T13:06:52.000Z","updated":"2020-05-15T12:49:17.000Z","comments":true,"path":"2020/05/12/Typora-PicGo-Gitee（书写博客神器）/","link":"","permalink":"https://alanwang.site/2020/05/12/Typora-PicGo-Gitee%EF%BC%88%E4%B9%A6%E5%86%99%E5%8D%9A%E5%AE%A2%E7%A5%9E%E5%99%A8%EF%BC%89/","excerpt":"写博客，难免会随手截图来解释博客中的一些知识点或者内容。当高高兴兴地在本地电脑写完博客后将它上传之后发现所有图片都浏览不了了，这其实就是因为图片都保存在本地了。为了解决这个问题，从长远和财力来考虑，我使用了gitee搭配开源项目PicGo来做图床生成在线图片链接，这样无论在哪都能畅通查看图片了。而不使用github主要是国内访问速度是非常地慢。","text":"写博客，难免会随手截图来解释博客中的一些知识点或者内容。当高高兴兴地在本地电脑写完博客后将它上传之后发现所有图片都浏览不了了，这其实就是因为图片都保存在本地了。为了解决这个问题，从长远和财力来考虑，我使用了gitee搭配开源项目PicGo来做图床生成在线图片链接，这样无论在哪都能畅通查看图片了。而不使用github主要是国内访问速度是非常地慢。 参考文章：https://blog.csdn.net/disILLL/article/details/104944710 开搞软件版本 typora 0.9.86 PicGo 2.2.2 创建gitee仓库在gitee账户中创建一个公开的仓库用来保存图片 PicGo配置这边安装有一个巨坑，不要安装在Programe Files目录下面，切记 安装gitee-uploader插件 安装完后配置gitee token在自己的gitee中创建 点击commit生成token，将token填入PicGo中点击确定即可。 检查一下端口号是不是36677，这是我踩过的一个坑 配置Typora实现插入图片自动上传新版本的Typora已经支持图片上传功能，具体配置如下（文件-&gt;偏好设置）： 测试可以看到这里图片的链接是之前在gitee中创建的用来保存图片的Repository的地址了 哈哈，成功了，这样效率就提高了许多了。","categories":[{"name":"效率工具","slug":"效率工具","permalink":"https://alanwang.site/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://alanwang.site/tags/Typora/"},{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"工具","slug":"工具","permalink":"https://alanwang.site/tags/%E5%B7%A5%E5%85%B7/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"面试造轮","slug":"前端/面试造轮","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%80%A0%E8%BD%AE/"},{"name":"记录生活","slug":"记录生活","permalink":"https://alanwang.site/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"},{"name":"2020","slug":"记录生活/2020","permalink":"https://alanwang.site/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/2020/"},{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://alanwang.site/categories/Hexo%E5%8D%9A%E5%AE%A2/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"},{"name":"测试分类","slug":"测试分类","permalink":"https://alanwang.site/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"},{"name":"效率工具","slug":"效率工具","permalink":"https://alanwang.site/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"},{"name":"面试题","slug":"面试题","permalink":"https://alanwang.site/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"记录生活","slug":"记录生活","permalink":"https://alanwang.site/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"},{"name":"Hexo","slug":"Hexo","permalink":"https://alanwang.site/tags/Hexo/"},{"name":"Valine","slug":"Valine","permalink":"https://alanwang.site/tags/Valine/"},{"name":"评论系统","slug":"评论系统","permalink":"https://alanwang.site/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"name":"DIY博客","slug":"DIY博客","permalink":"https://alanwang.site/tags/DIY%E5%8D%9A%E5%AE%A2/"},{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"},{"name":"ReactHook","slug":"ReactHook","permalink":"https://alanwang.site/tags/ReactHook/"},{"name":"jwt","slug":"jwt","permalink":"https://alanwang.site/tags/jwt/"},{"name":"部署","slug":"部署","permalink":"https://alanwang.site/tags/%E9%83%A8%E7%BD%B2/"},{"name":"阿里云","slug":"阿里云","permalink":"https://alanwang.site/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"测试标签","slug":"测试标签","permalink":"https://alanwang.site/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"},{"name":"Typora","slug":"Typora","permalink":"https://alanwang.site/tags/Typora/"},{"name":"工具","slug":"工具","permalink":"https://alanwang.site/tags/%E5%B7%A5%E5%85%B7/"}]}