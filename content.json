{"meta":{"title":"Alan|前端博客","subtitle":"","description":"一个专注于前端开发的小白，分享前端开发知识","author":"Alan","url":"https://alanwang.site","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-05-13T09:03:12.444Z","updated":"2020-05-13T09:03:12.444Z","comments":true,"path":"404.html","permalink":"https://alanwang.site/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2020-05-14T12:42:42.500Z","updated":"2020-05-14T12:42:42.500Z","comments":true,"path":"about/index.html","permalink":"https://alanwang.site/about/index.html","excerpt":"","text":"Alan 待完善"},{"title":"所有分类","date":"2020-05-14T12:46:25.030Z","updated":"2020-05-14T12:46:25.030Z","comments":true,"path":"categories/index.html","permalink":"https://alanwang.site/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-05-14T12:58:35.975Z","updated":"2020-05-14T12:58:35.975Z","comments":true,"path":"tags/index.html","permalink":"https://alanwang.site/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-14T13:02:13.019Z","updated":"2020-05-14T13:02:13.019Z","comments":true,"path":"list/index.html","permalink":"https://alanwang.site/list/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-05-14T13:25:42.778Z","updated":"2020-05-14T13:25:42.778Z","comments":true,"path":"friends/index.html","permalink":"https://alanwang.site/friends/index.html","excerpt":"","text":"要添加友链的朋友按照下面格式给我留言😘 12345678items:- name: # 博客名 必填 avatar: # 头像链接 必填 url: # 博客链接 必填 backgroundColor: &#39;#3E74C9&#39; # 卡片背景颜色 textColor: &#39;#fff&#39; # 卡片文字颜色 tags: [标签1, 标签2] # 标签 desc: 描述文字"}],"posts":[{"title":"webpack4.0进阶（一）","slug":"webpack4.0进阶（一）","date":"2020-05-25T06:43:46.000Z","updated":"2020-05-27T08:33:00.000Z","comments":true,"path":"2020/05/25/webpack4.0进阶（一）/","link":"","permalink":"https://alanwang.site/2020/05/25/webpack4.0%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"webpack4.0进阶学习","text":"webpack4.0进阶学习 Tree Shaking按需打包文件index.jsmoment.js123import &#123; used &#125; from './moment';used();1234567export function used() &#123; console.log('used function');&#125;export function notUsed() &#123; console.log('notUsed funtion');&#125; 上面这个例子中我们只使用到了moment中的used，但是打包后连同notUsed一起被打包进了main.js文件中 Tree Shaking可以帮我们解决这个问题。 注意：1.Tree Shaking只在production模式下生效。2.只支持ES Module 语法（import），不支持CommonJs package.jsonwebpack.config.js123456789101112\"sideEffects\": false,或者\"sideEffects\": [ \"**/*.css\", \"**/*.scss\", \"./esnext/index.js\", \"./esnext/configure.js\"],意思是对这些文件不进行tree shaking处理例如import './common.css';虽然我们没有使用common.css的一些东西，但是它起到了样式的作用的，如果不在sideEffect中设置的话，webpack是不会对它进行打包的。1234optimization: &#123; usedExports: true,&#125;// production模式是会自动配置好，可写可不写 开发环境和生产环境配置文件由于开发环境需要调试代码所以会引入devServer之类的插件，那么这部分插件在生产环境中是不需要使用到的，我们可以对开发环境和生产环境分别设置不同的配置文件。 首先安装插件webpack-merge用来将拼接common配置 1npm i webpack-merge -D 目录如下： webpacktest ├── package.json ├── src │ ├── index.html │ ├── index.js │ └── moment.js ├── webpack.common.js ├── webpack.dev.js └── webpack.prod.js webpack.common.jswebpack.dev.jswebpack.prod.jsnpm script12345678910111213141516171819202122232425262728293031323334353637const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', // 默认为production entry: &#123; main: './src/index.js', // 打包入口文件 &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 loader: 'babel-loader' &#125;, &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'], &#125;, ], &#125;, output: &#123; // 输出文件配置 filename: '[name].js', path: path.resolve(__dirname, 'dist'), &#125;, optimization: &#123; usedExports: true, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', &#125;), new CleanWebpackPlugin(), ],&#125;;123456789101112131415const merge = require('webpack-merge');const commonConfig = require('./webpack.common.js');const devConfig = &#123; mode: 'development', // 默认为production devtool: 'cheap-module-eval-source-map', devServer: &#123; contentBase: './dist', open: true, // 自动打开浏览器 port: 3001, // 服务器端口号 hot: true, // 开启HRM &#125;&#125;;module.exports = merge(commonConfig, devConfig);123456789const merge = require('webpack-merge');const commonConfig = require('./webpack.common.js');const prodConfig = &#123; mode: 'development', // 默认为production devtool: 'cheap-module-source-map'&#125;;module.exports = merge(commonConfig, prodConfig);1234\"scripts\": &#123; \"dev\": \"webpack-dev-server --config webpack.dev.js\", \"build\": \"webpack --config webpack.prod.js\"&#125;, 配置好后，开发环境使用npm run dev进行打包，生产环境用npm run build进行打包。 代码分割代码分割有利于性能的优化。何为代码分割： 有这么一个场景，我在index.js中使用到了一些公共代码库/工具库（lodash），index.js中的代码是依赖于lodash中的一些工具的。当我们打包时，lodash也是被打包到了main.js文件中，并且一旦index.js中的业务代码改变了，连同lodash也要一同重新打包加载，但是我们一般是不会去改动lodash这类工具库的。于是我们可以借助代码分割来将业务代码和lodash进行分割，这样下次再修改业务代码时，我们就无需重新加载lodash的内容了。 先安装lodash 1npm i lodash -S 这里为了便于查看打包后的文件内容，我们加上一条npm script&quot;start&quot;: &quot;webpack --config webpack.dev.js&quot;(由于devServer不会生成打包内容) index.js 123import _ from 'lodash';console.log(_.compact([0, 1, false, 2, '', 3])); npm run start打包，发现打包后的main.js文件中包含lodash内容。 那如何实现代码分割呢，只需配置webpack.common.js文件 12345optimization: &#123; splitChunks: &#123; chunks: 'all' &#125;&#125; 再次打包，发现打包后的文件中多了一个vendor~main.js，webpack自动将lodash内容打包进去了，而main.js文件中就没有了lodash的内容了。 dist ├── index.html ├── main.js └── vendors~main.js 上面介绍的时同步代码分割，下面看一下异步代码分割index.js，可以实现懒加载 123456789101112async function createElement() &#123; const &#123; default: _ &#125; = await import(/* webpackChunkName: \"lodash\" */'lodash'); const element = document.createElement('div'); element.innerHTML = _.compact([0, 1, false, 2, '', 3]); return element;&#125;document.addEventListener('click', () =&gt; &#123; createElement().then(element =&gt; &#123; document.body.appendChild(element); &#125;)&#125;) /* webpackChunkName: &quot;lodash&quot; */设置打包后的文件名为vendors~lodash.js，打开浏览器可以看到只有点击页面时，才会引入vendors~lodash.js，实现了懒加载。 打包后的目录 12345dist ├── index.html ├── main.js ├── vendors~lodash.js └── vendors~main.js 当然可以通过其他配置来设置打包后的文件名称。 代码分割更多配置 打包分析工具首先要拿到status.json文件，具体获取方式只需配置npm script即可 1\"start\": \"webpack --profile --json &gt; status.json --config webpack.dev.js\", 打包后会生成status.json文件。 然后使用官网提供的一些工具就可以可视化分析打包结果了。 在写代码时，我们要尽可能的使用异步引入，这样可以提高代码的使用率，提升性能，减少加载不必要的代码。 查看代码使用率的方法，浏览器控制台按下ctrl+shift+p，输入show coverage 代码优化现在有一个优化场景，我有一个登录按钮，当点击按钮后弹出登录框。这里的优化思路是，页面加载时只加载登录按钮的代码，当按钮代码加载完后。利用空闲时间去加载登录框的代码。这样既可以优化首屏加载速度，还可以解决因使用懒加载登录框（也就是点击按钮后再去加载）而带来的用户体验较差的问题。 具体代码：(只需要在import中加入/* webpackPrefetch: true */) index.jsloginModal.js12345document.addEventListener('click', () =&gt; &#123; import(/* webpackPrefetch: true */'./loginModal.js').then((&#123;default: login&#125;) =&gt; &#123; login(); &#125;)&#125;)123export default function () &#123; alert('loginModal');&#125; css文件处理MiniCssExtractPlugin This plugin should be used only on production builds without style-loader in the loaders chain, especially if you want to have HMR in development. 官方推荐不要在开发环境中使用，因为不支持HMR，不利于提高开发效率。 1npm install --save-dev mini-css-extract-plugin index.jsstyle.css1import './style.css';123body &#123; background: #e65;&#125; webpack.common.jswebpack.dev.jswebpack.prod.jspackage.json12345678910111213141516171819202122232425262728293031323334353637const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', // 默认为production entry: &#123; main: './src/index.js', // 打包入口文件 &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 loader: 'babel-loader', &#125;, ], &#125;, output: &#123; // 输出文件配置 filename: '[name].js', chunkFilename: '[name].chunk.js', path: path.resolve(__dirname, 'dist'), &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/index.html', &#125;), new CleanWebpackPlugin(), ], optimization: &#123; usedExports: true, splitChunks: &#123; chunks: 'all', &#125;, &#125;,&#125;;1234567891011121314151617181920212223const merge = require('webpack-merge');const commonConfig = require('./webpack.common.js');const devConfig = &#123; mode: 'development', devtool: 'cheap-module-eval-source-map', devServer: &#123; contentBase: './dist', open: true, // 自动打开浏览器 port: 3001, // 服务器端口号 hot: true, // 开启HRM &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'], &#125; ], &#125;,&#125;;module.exports = merge(commonConfig, devConfig);123456789101112131415161718192021const merge = require('webpack-merge');const commonConfig = require('./webpack.common.js');const MiniCssExtractPlugin = require('mini-css-extract-plugin');const prodConfig = &#123; mode: 'development', devtool: 'cheap-module-source-map', module: &#123; rules: [ &#123; test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'], &#125; ], &#125;, plugins: [ new MiniCssExtractPlugin(&#123;&#125;) ]&#125;;module.exports = merge(commonConfig, prodConfig);123\"sideEffects\": [ \"*.css\"], 也可以使用optimize-css-assets-webpack-plugin来压缩css代码","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"记录生活2020/5","slug":"记录生活2020-5","date":"2020-05-22T14:50:26.000Z","updated":"2020-05-22T14:50:26.000Z","comments":true,"path":"2020/05/22/记录生活2020-5/","link":"","permalink":"https://alanwang.site/2020/05/22/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB2020-5/","excerpt":"这是一篇记录5月生活的个人随记。📝","text":"这是一篇记录5月生活的个人随记。📝 2020-05-22现在是22:53，我的论文初稿终于上传审核了🎈，查重率4.8%。记录一下，后天就要线上答辩了。","categories":[{"name":"记录生活","slug":"记录生活","permalink":"https://alanwang.site/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"},{"name":"2020","slug":"记录生活/2020","permalink":"https://alanwang.site/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/2020/"}],"tags":[{"name":"记录生活","slug":"记录生活","permalink":"https://alanwang.site/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"}]},{"title":"webpack4.0学习总结（四）","slug":"webpack4.0学习总结（四）","date":"2020-05-18T02:24:19.000Z","updated":"2020-05-20T07:19:00.000Z","comments":true,"path":"2020/05/18/webpack4.0学习总结（四）/","link":"","permalink":"https://alanwang.site/2020/05/18/webpack4.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"webpack的devServer热更新以及HMR局部热更新","text":"webpack的devServer热更新以及HMR局部热更新 DevServerDevServer可以起一个本地服务并且实现代码的热更新。可以省去我们每次更新代码后重启服务额操作。 1npm i webpack-dev-server -D 配置文件 package.jsonwebpack.config.js1234\"scripts\": &#123; \"build\": \"webpack\", \"start\": \"webpack-dev-server\"&#125;,12345devServer: &#123; contentBase: './dist', open: true, // 自动打开浏览器 port: 3001, // 服务器端口号&#125;, 我们之后只需要使用npm run start就可以把服务跑起来了，之后只要改动代码就会自动更新了，开发效率提高了很多有没有😝 devServer更多配置内容 HMR实现局部热更新HMR（Hot Module Replacement） 当我们更改了部分文件后，我们发现webpack-dev-server帮我们重新渲染所有内容，假如我只改动了一小部分，只想更新这一部分内容就可以用了使用HMR来实现了。 说再多不如看一个例子 index.jsindex.css1234567891011import './index.css';var root = document.getElementById('root');root.innerHTML = '&lt;button id=\"btn\"&gt;add new block&lt;/button&gt;';document.getElementById('btn').onclick = function() &#123; var newBlock = document.createElement('p'); newBlock.innerHTML = 'new Block'; root.append(newBlock);&#125;123456p &#123; width: 100px;&#125;p:nth-child(6) &#123; background: red;&#125; 这里例子就是点击按钮添加一个p元素，第6个p元素显示为红色背景 这个时候我觉得红色不好看，想换成黄色，修改，保存一气呵成。 结果webpack-dev-server给我全部重新渲染了，我还要再点6下才能看到效果，这里如果是1000（虽然不太可能）呢，那我岂不是要点1000下😱。 这个时候配置HRM就可以轻松解决这个问题了。 只需要再webpack.config.js中配置 123456devServer: &#123; contentBase: './dist', open: true, // 自动打开浏览器 port: 3001, // 服务器端口号 hot: true, // 开启HRM&#125;, 搞定😎，不过这里由于有css-loader帮我们做了一些更新的任务，所以我们并没有写过多的代码。那如果没有css-loader处理那怎么办？下面看一下具体配置。 index.jscounter.jsnumber.js12345import Counter from './counter'import Number from './number'Counter();Number();123456789101112function Counter() &#123; var root = document.getElementById('root'); var counter = document.createElement('div'); counter.innerHTML = 0; counter.onclick = function () &#123; counter.innerHTML = parseInt(counter.innerHTML, 10) + 1; &#125; root.append(counter); &#125;export default Counter;123456789function Number() &#123; var root = document.getElementById('root'); var data = document.createElement('div'); data.setAttribute('id', 'number'); data.innerHTML = '2000'; root.append(data);&#125;export default Number; 可以看到当我一改变number，counter中的状态又重新渲染变成0了😩。 这里我们就要通过一部分代码来处理一下了（css-loader就是帮我们完成了这部分工作） 123456789101112131415import Counter from './counter'import Number from './number'Counter();Number();if (module.hot) &#123; // 如果开启HMR module.hot.accept('./number.js', () =&gt; &#123; var root = document.getElementById('root'); root.removeChild(document.getElementById('number')); console.log('number is updated'); Number(); // 一旦number.js文件改变，进行一系列处理 &#125;)&#125; HMR详细文档 处理ES6语法我们先用ES6写一些代码 12345678910const name = 'Alan';const list = [1, 8, 4, 6];const resultList = list.filter(item =&gt; item &gt; 5);new Promise(() =&gt; &#123; console.log('666');&#125;)console.log(resultList); npm run build打包看一下chrome效果 奈何这个世界上还有IE这种东西😣，IE上看一下效果 可以看一下报错的地方： 1eval(\"const name = 'Alan';\\r\\nconst list = [1, 8, 4, 6];\\r\\n\\r\\nconst resultList = list.filter(item =&gt; item &gt; 5);\\r\\n\\r\\nnew Promise(() =&gt; &#123;\\r\\n console.log('666');\\r\\n&#125;)\\r\\n\\r\\nconsole.log(resultList);\\r\\n\\n\\n//# sourceURL=webpack:///./src/index.js?\"); 看来IE是识别不了ES6语法的，那我们这里就要借助babel处理了。 1npm install --save-dev babel-loader @babel/core @babel/preset-env @babel/preset-env把ES6转化为ES5 @babel/corebabel核心内容 配置webpack 12345678&#123; test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'] &#125;&#125;, 再打包看一看 打包后的index.js文件 123456789var name = 'Alan';var list = [1, 8, 4, 6];var resultList = list.filter(function (item) &#123; return item &gt; 5;&#125;);new Promise(function () &#123; console.log('666');&#125;);console.log(resultList); 虽然处理了一些ES6语法（箭头函数，const），但是像filter和Promise还是没有处理的。 这里就要使用@babel-polyfill，它会模拟一个ES5环境 1npm install --save @babel&#x2F;polyfill 安装后在文件开头引入就可以了 123456789101112import '@babel/polyfill';const name = 'Alan';const list = [1, 8, 4, 6];const resultList = list.filter(item =&gt; item &gt; 5);new Promise(() =&gt; &#123; console.log('666');&#125;)console.log(resultList); 再次打包运行 虽然效果完成了，但是对比一下没使用@babel/polyfill和使用了@babel/polyfill打包后的大小😮 就引入了一个@babel-polyfill，体积就增加了这么多？ 其实是因为@babel-polyfill模拟了所有的ES5环境，而我们这里只使用了Promise和filter，所以我们可以通过配置useBuiltIns让它只模拟我们使用到的。 配置了useBuiltIns后，它是会自动帮我们引入@babel/polyfill所以这里我们无需再引入。 12345678910&#123; test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 loader: 'babel-loader', options: &#123; presets: [['@babel/preset-env', &#123; useBuiltIns: 'usage' &#125;]] &#125;&#125;, 1main.js 68.6 KiB main [emitted] main 再看一下打包后的文件小了很多有没有？ babel的配置是可以单独放在.babelrc文件中的，直接将options中的内容放到.babelrc目录下即可 12345&#123; \"presets\": [[\"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\" &#125;]]&#125; 使用@babel/preset-react打包React文件1npm install --save-dev @babel&#x2F;preset-react .babelrcindex.js1234567&#123; \"presets\": [[\"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\" &#125;], \"@babel/preset-react\" ]&#125;123456789101112import React, &#123; Component &#125; from 'react';import ReactDom from 'react-dom';class App extends Component &#123; render() &#123; return ( &lt;div&gt;Hello React&lt;/div&gt; ); &#125;&#125;ReactDom.render(&lt;App /&gt;, document.getElementById('root')); 这里有一点需要注意一下，presets顺序是从后往前的，和css-loader一样，也就是js文件是先被@babel/preset-react处理的再被@babel/preset-env处理的。 总结使用的babel@babel/preset-react处理react的jsx语法 @babel-polyfill处理低版本浏览器无法处理的语法，类似Promise、Array.from、Object.assign @babel/preset-env把ES6转化为ES5 @babel/corebabel核心内容 useBuiltIns:usage按需引入 更多配置参考babel官网","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"webpack4.0学习总结（三）","slug":"webpack4.0学习总结（三）","date":"2020-05-17T02:05:14.000Z","updated":"2020-05-16T05:33:00.000Z","comments":true,"path":"2020/05/17/webpack4.0学习总结（三）/","link":"","permalink":"https://alanwang.site/2020/05/17/webpack4.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"这节介绍了webpack一些常用的plugins的使用","text":"这节介绍了webpack一些常用的plugins的使用 我的总结篇的第一节中提到了index.html是需要我们手动移动到打包后的dist目录下的，那我比较懒能不能让webpack来帮我完成呢。🤔 这个时候plugins就派上了用场。 html-webpack-plugin The HtmlWebpackPlugin simplifies creation of HTML files to serve your webpack bundles. This is especially useful for webpack bundles that include a hash in the filename which changes every compilation. You can either let the plugin generate an HTML file for you, supply your own template using lodash templates, or use your own loader. 官网介绍到，它可以帮我们自动创造HTML文件，并且还可以使用自定义的HTML模板。 直接看例子： 1npm i html-webpack-plugin -D webpacktest ├── package-lock.json ├── package.json ├── src │ └── index.js └── webpack.config.js index.jswebpack.config.js123var root = document.getElementById('root');root.innerHTML = '&lt;div&gt;Hello Webpack&lt;/div&gt;'123456789101112131415const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: 'development', // 默认为production entry: &#123; main: './src/index.js', // 打包入口文件 &#125;, output: &#123; // 输出文件配置 filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), &#125;, plugins: [new HtmlWebpackPlugin()]&#125;; npm run build进行打包看下结果 webpacktest ├── dist │ ├── bundle.js │ └── index.html ├── package-lock.json ├── package.json ├── src │ └── index.js └── webpack.config.js HtmlWebpackPlugin插件自动为我们生成了index.html，但是…浏览器打开index.html一看什么都没有。这是咋回事，来看一看生成的index.html文件发现了问题 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Webpack App&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt; &lt;body&gt; &lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 生成的文件中是没有#root节点的，那怎么办？我们还需要配置一下HtmlWebpackPlugin，前面官网的介绍中也提到了 You can either let the plugin generate an HTML file for you, supply your own template using lodash templates, or use your own loader 我们需要自己提供一个HTML模板，于是在src目录下创建一个index.html作为HtmlWebpackPlugin打包的模板 index.htmlwebpack.config.js1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;html template&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;123plugins: [new HtmlWebpackPlugin(&#123; template: './src/index.html'&#125;)] 再打包一次看一下dist目录下生成的index.html文件和我们定义的html模板是一样的了。 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;html template&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script src=\"bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开浏览器发现Hello Webpack也正确显示出来了。🎉 clean-webpack-pluginhttps://www.npmjs.com/package/clean-webpack-plugin 它的作用就是在每次打包前会将webpack中配置的out.path(dist目录)清空 1npm i clean-webpack-plugin -D 为了验证是否清空了dist目录，我们先在dist目录下自己创建一个文件my.js dist ├── bundle.js ├── index.html └── my.js 123456789101112131415161718const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', // 默认为production entry: &#123; main: './src/index.js', // 打包入口文件 &#125;, output: &#123; // 输出文件配置 filename: 'bundle.js', path: path.resolve(__dirname, 'dist'), &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;), new CleanWebpackPlugin()]&#125;; npm run build打包 dist ├── bundle.js └── index.html 我们发现之前创建的my.js文件已经被CleanWebpackPlugin给清除了。 多入口文件有时我们的打包入口文件有多个，这时候就要通过设置entry来完成打包。并通过[name]占位符来设置打包出来的文件的名称。 12345678910111213141516171819const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', // 默认为production entry: &#123; main: './src/index.js', // 打包入口文件 enrty: './src/entry.js', &#125;, output: &#123; // 输出文件配置 filename: '[name].js', path: path.resolve(__dirname, 'dist'), &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;), new CleanWebpackPlugin()]&#125;; npm run build打包结果 dist ├── enrty.js ├── index.html └── main.js 看一看index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;html template&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt;&lt;script src=\"main.js\"&gt;&lt;/script&gt;&lt;script src=\"enrty.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 可以看到HtmlWebpackPlugin帮我们把main.js和entry.j2个文件都自动引入到html文件当中了。 在实际业务场景中，为了优化服务器性能，我们会将打包好的dist目录中的一部分文件丢到cdn中来加快访问速度。这时候我们就要将cdn的地址手动复制到打包后的html文件中了，不过我们可以通过设置output的publicPath来完成。 123456output: &#123; // 输出文件配置 filename: '[name].js', publicPath: 'https://cdn.example.com/assets', path: path.resolve(__dirname, 'dist'),&#125;, 打包后的效果 1&lt;script src=\"https://cdn.example.com/assets/main.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.example.com/assets/enrty.js\"&gt;&lt;/script&gt; SourceMapsourcemap是什么，我们修改一下index.js文件内容并且在webpack配置中关闭sourcemap(devtool: ‘none’) index.jswebpack.config.js12345var root = document.getElementById('root');errfun();root.innerHTML = '&lt;div&gt;Hello Webpack&lt;/div&gt;'1234567891011121314151617181920const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', // 默认为production devtool: 'none', entry: &#123; main: './src/index.js', // 打包入口文件 enrty: './src/entry.js', &#125;, output: &#123; // 输出文件配置 filename: '[name].js', path: path.resolve(__dirname, 'dist'), &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: './src/index.html' &#125;), new CleanWebpackPlugin()]&#125;; index.js中使用了一个不存在的函数errfun()，打包运行一下是会报错的。 这个时候我们想要调试代码，但是它这里提示的错误行是打包后的main.js所在的位置。 现在我们配置sourcemap看看。 1devtool: 'source-map', 这个时候我们就能定位到错误是出现在我们index.js的第三行了。 配置不同sourceMap会不同程度上增加应用的打包时间或消耗性能 官网提供了多种sourceMap配置，不同sourceMap打包消耗时间不同，详情。 sourcemap其实就是main.js和index.js之间的一种映射关系，在代码存在错误时，它能根据映射关系找到index.js中的错误所在处，有利于我们debug代码。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"valine国际版邮件回复","slug":"valine国际版邮件回复","date":"2020-05-16T08:02:54.000Z","updated":"2020-05-16T08:02:54.000Z","comments":true,"path":"2020/05/16/valine国际版邮件回复/","link":"","permalink":"https://alanwang.site/2020/05/16/valine%E5%9B%BD%E9%99%85%E7%89%88%E9%82%AE%E4%BB%B6%E5%9B%9E%E5%A4%8D/","excerpt":"本博客评论系统使用了valine国际版，支持评论邮件提醒","text":"本博客评论系统使用了valine国际版，支持评论邮件提醒 准备工作注册一个LeanCloud国际版账号（国内的好像需要绑定域名和备案）注册地址👉https://console.leancloud.app/login.html#/signup 之后创建一个应用，名字随便取 在设置中找到应用keys,把appid和appkey复制到hexo对应的配置当中。由于本文重点讲邮件回复功能，这一部分就不多过赘述了😝。直接进入正题。 修改邮件模板 12345&lt;p&gt;Hi, &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;p&gt;你在 &#123;&#123;appname&#125;&#125; 的评论收到了新的回复，请点击查看：&lt;/p&gt;&lt;p&gt;&lt;a href=\"https://alanwang.site\" style=\"display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;\"&gt;马上查看&lt;/a&gt;&lt;/p&gt; 部署valine-admin首先进行配置 更多配置参考：https://github.com/DesertsP/Valine-Admin 1https:&#x2F;&#x2F;github.com&#x2F;DesertsP&#x2F;Valine-Admin.git 网上的zhaojun1998版本我之前也试过，但是在国际版部署是会报错的，看错误信息应该是node版本太低了，而且就算部署成功了，后台也是登录不了的。这个版本我实测是没有问题的。 部署分支默认为master 点击部署即可 点击该链接访问后台管理系统（这里需要用户名和密码登录，需要到存储中的_User中自行创建） 这里只需要填写username、password、email即可，添加后在后台管理系统输入邮箱和密码就可以成功登录了。 设置定时唤醒 10 */30 7-23 * * ?","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://alanwang.site/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://alanwang.site/tags/Hexo/"},{"name":"valine","slug":"valine","permalink":"https://alanwang.site/tags/valine/"},{"name":"评论系统","slug":"评论系统","permalink":"https://alanwang.site/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"webpack4.0学习总结（二）","slug":"webpack4.0学习总结（二）","date":"2020-05-15T12:00:22.000Z","updated":"2020-05-16T05:33:00.000Z","comments":true,"path":"2020/05/15/webpack4.0学习总结（二）/","link":"","permalink":"https://alanwang.site/2020/05/15/webpack4.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"这节主要讲一讲一些常见的Loder的使用。包括file-loader、url-loader以及css-loader和style-loader。","text":"这节主要讲一讲一些常见的Loder的使用。包括file-loader、url-loader以及css-loader和style-loader。 Loaderfile-loader上一节简单介绍了webpack是什么，webpack是一个模块打包器，可以将es的模块文件进行打包。上一节我们只打包了js文件，那我们能不能打包其他类型的文件呢，先来试一试打包图片吧。 这里使用到了file-loader 1npm i file-loader -D index.jswebpack.config.js123456789101112131415// ES Moudule 模块化引入import ComponentB from './componentB';var root = document.getElementById('root');// CommonJs 模块引入var ComponentA = require('./componentA');var img1 = require('./IMG_3294.jpg');console.log(img1);var img = new Image();img.src = img1;root.append(img);new ComponentA();new ComponentB();12345678910111213141516171819202122const path = require('path');module.exports = &#123; mode: 'development', // 默认为production entry: &#123; main: './src/index.js' // 打包入口文件 &#125;, module: &#123; rules: [ &#123; test: /\\.jpg$/, use: &#123; loader: 'file-loader' &#125; &#125; ] &#125;, output: &#123; // 输出文件配置 filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; npm run build进行打包，我们看一下控制台打印出来的img1 这里可以看到img1是一个Module。 我们可以通过img1.default来获取路径或者直接通过import形式来引入，这样图片就成功得显示出来了😄 1import img1 from './IMG_3294.jpg' 通过这个例子可以知道了loader的大致作用方法了，通过test来匹配特定文件使用（use)特定的loader来对文件进行打包处理。 我们再看一下打包出来的文件 dist ├── a2099657cfcaf9f019ccf08e9dc8747d.jpg ├── bundle.js └── index.html 发现我们的图片名称被改变成了一长串字符，那我怎么让它不改变名字呢。这时候loader的options就派上用场了😎 1234567891011rules: [ &#123; test: /\\.(jpg|png)$/, use: &#123; loader: 'file-loader', options: &#123; name: '[name].[ext]' &#125; &#125; &#125;] 这里的[name]和[ext]是loader中的placeholder,分别表示文件的名字和后缀名，当然loader中还有很多的placeholder。 设置好后进行打包得到如下结果 dist ├── bundle.js ├── IMG_3294.jpg └── index.html 现在有一个问题，当我们的图片一旦多起来那全部打包放在根目录下拿岂不是很乱，这个时候就可以使用options中的output来规定经过loader处理后的输出路径了。 1234options: &#123; name: '[name].[ext]', outputPath: 'images/'&#125; 打包看一下结果成功👌，运行一下html文件图片也可以正常显示。 dist ├── bundle.js ├── images │ └── IMG_3294.jpg └── index.html 到这里我们就了解了file-loader的基本使用了。 url-loaderurl-loader也可以打包文件，但是和file-loader不同的是，它会将我们的图片转化成base64编码，那如果我不想转化呢，我们可以使用options中的limit属性来限制文件在小于多少时转化成base64编码，一旦大于这个值打包出来的效果就和file-loader一样了。 看一下例子就清楚了 1npm i url-loader -D 这里准备两个图片，一个大小300k，一个大小7k webpack配置 123456789101112131415161718192021222324252627const path = require('path');module.exports = &#123; mode: 'development', // 默认为production entry: &#123; main: './src/index.js' // 打包入口文件 &#125;, module: &#123; rules: [ &#123; test: /\\.(jpg|png)$/, use: &#123; loader: 'url-loader', options: &#123; name: '[name].[ext]', outputPath: 'images/', limit: 10240 &#125; &#125; &#125; ] &#125;, output: &#123; // 输出文件配置 filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 看一下打包后的文件 dist ├── bundle.js ├── images │ └── 300k.jpg └── index.html 结果是大于10240的300k.jpg文件被以图片形式打包出来了，那7k.jpg文件去哪了呢，我们在bundle.js文件中可以找到了它，它被转化成了base64编码。 1data:image&#x2F;jpeg;base64,&#x2F;9j&#x2F;4AAQSkZJRgABAQEAYABgAAD... 当然limit也可以设置为true/false，更多配置 我在操作中发现了如果html中没有使用到7k.jpg，url-loader是不会对它进行打包的。 这里并不建议把大文件转化为base64，这样会增加bundle.js的体积，对项目优化不太友好 样式文件接着上面的例子，我现在想要为页面中的图片添加一些样式 index.jsindex.css123456789101112131415161718// ES Moudule 模块化引入import ComponentB from './componentB';import './index.css';var root = document.getElementById('root');// CommonJs 模块引入var ComponentA = require('./componentA');import img1 from './300k.jpg';console.log(img1);var img = new Image();img.src = img1;img.classList.add('circle');root.append(img);new ComponentA();new ComponentB();12345.circle &#123; width: 100px; height: 100px; border-radius: 50px;&#125; 现在我想要打包css文件该怎么办呢😶，我们要用到两个loader，css-loader和style-loader 安装 1npm i style-loader css-loader -D webpack配置 1234&#123; test: /\\.css$/, use: ['style-loader', 'css-loader']&#125; 打包成功，打开网页看一看效果生效了 这里简单介绍一下style-loader和css-loader的作用，首先它们执行有先后顺序的，先使用css-loader对css文件进行打包，再用style-loader把打包后的css文件内容以&lt;style&gt;&lt;/style&gt;加到页面的header中。 有时候我们要为css加上浏览器引擎前缀-webkit，这里有一个loader可以帮我们完成postcss-loader 安装 1npm i postcss-loader autoprefixer -D webpack配置 123456789101112&#123; test: /\\.css$/, use: ['style-loader', 'css-loader', &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', pulgins: [ require('autoprefixer') ] &#125; &#125;],&#125;, 这里貌似有点问题，后期我再研究研究。 扩展css模块化先看一个场景 index.jscomponentA.js123456789101112import './index.css';import img1 from './300k.jpg';import ComponentA from './componentA';var root = document.getElementById('root');var img = new Image();img.src = img1;img.classList.add('circle');root.append(img);ComponentA();1234567891011import img1 from './300k.jpg';function ComponentA() &#123; var img = new Image(); img.src = img1; img.classList.add('circle'); var root = document.getElementById('root'); root.append(img);&#125;export default ComponentA; 我们看到circle样式同样作用在了componentA上了，也就是说circle已经等同于是全局样式了😥。还好我们可以通过配置css-loader的options来使用css的模块化来解决这个问题。 12345678910111213141516171819&#123; test: /\\.css$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; modules: true, &#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', pulgins: [require('autoprefixer')], &#125;, &#125;, ],&#125;, 配置好后我们在要使用样式的地方使用下面这种写法 123import circle from './index.css';img.classList.add(circle.circle); 这样我们再修改样式就不会影响到其他地方了。 css外部引入这里主要介绍css-loader的optionsimportLoaders。 我们在index.css文件中引入外部css文件 1@import './import.css'; 假设我们有以下几个loader处理css文件 [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;, &#39;postcss-loader&#39;] 当webpack处理index.css文件时按照postcss-loader-&gt;sass-loader-&gt;css-loader顺序来执行css文件的 当遇到@import时处理import.css时，如果不做处理的话，import.css将直接从css-loader开始处理的，那我想让它从postcss-loader从头处理的话就要设置imortLoaders数目了。 123456&#123; loader: 'css-loader', options: &#123; importLoaders: 1, &#125;&#125;, 这里的1表示处理@import引入的css文件是，先要被前面的1个loader处理，也就是import.css的处理顺序是sass-loader-&gt;css-loader-style-loader。 处理字体文件直接使用file-loader处理就可以了 webpack.config.jsindex.jsiconfont.css123456&#123; test: /\\.(eot|ttf|svg|woff)$/, use: &#123; loader: 'file-loader', &#125;,&#125;,12345import './font/iconfont.css';var root = document.getElementById('root');root.innerHTML = '&lt;div class=\"iconfont icon-smile\"&gt;&lt;/div&gt;'1234567891011121314151617181920@font-face &#123;font-family: \"iconfont\"; src: url('iconfont.eot?t=1589604469136'); /* IE9 */ src: url('iconfont.eot?t=1589604469136#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('data:application/x-font-woff2;charset=utf-8;base64,这里base64代码太长删除掉了') format('woff2'), url('iconfont.woff?t=1589604469136') format('woff'), url('iconfont.ttf?t=1589604469136') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url('iconfont.svg?t=1589604469136#iconfont') format('svg'); /* iOS 4.1- */&#125;.iconfont &#123; font-family: \"iconfont\" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.icon-smile:before &#123; content: \"\\e783\";&#125; ok!这章到此介绍。现在我们已经能够处理一些常见文件的打包了，对webpack的认识也应该算一个简单的入门了。😁","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"webpack4.0学习总结（一）","slug":"webpack4.0学习总结（一）","date":"2020-05-14T08:01:46.000Z","updated":"2020-05-14T08:01:46.000Z","comments":true,"path":"2020/05/14/webpack4.0学习总结（一）/","link":"","permalink":"https://alanwang.site/2020/05/14/webpack4.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"这一篇文章主要简单介绍了webpack是什么以及webpack的一些简单配置，你只要跟着我敲完这些代码后一定会对webpack有一个基本的了解的。😎","text":"这一篇文章主要简单介绍了webpack是什么以及webpack的一些简单配置，你只要跟着我敲完这些代码后一定会对webpack有一个基本的了解的。😎 webpack是一个模块打包器 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 上面引用了webpack官网的一段介绍，我们可以简单的理解webpack是一个模块打包器，那什么是模块打包器呢？😂先看一个简单的例子 index.htmlindex.jscomponentA.jscomponentB.js123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;12345678910// ES Moudule 模块化引入import ComponentB from './componentB';var root = document.getElementById('root');// CommonJs 模块引入var ComponentA = require('./componentA');new ComponentA();new ComponentB();1234567function ComponentA() &#123; var componentA = document.createElement('div'); componentA.innerHTML = 'ComponentA'; root.append(componentA);&#125;module.exports = ComponentA;1234567function ComponentB() &#123; var componentB = document.createElement('div'); componentB.innerHTML = 'ComponentB'; root.append(componentB);&#125;export default ComponentB; 这里的模块可以理解成componentA和componentB，这种写法在vue和react中非常常见，写完这些文件后打开index.html文件，浏览器是会报错的。 Uncaught SyntaxError: Cannot use import statement outside a module 这是由于这里使用了es6中的模板引入的方式，浏览器是识别不了这种方式的，那怎么办呢？😥 这个时候webpack就派上用场了，首先初始化该项目 1npm init -y 初始化后会生成package.json文件 安装webpack-cli和webpack（不建议全局安装） 12npm install webpack-cli -Dnpm install webpack -S 安装固定版本的webpack 12npm install webpack@版本号npm info webpack &#x2F;&#x2F; 查看包信息 打包index.js 1npx webpack index.js 这里如果不使用npx的话node会默认在全局环境中找寻webpack，加上npx的话就会使用项目中安装的webpack来执行命令 打包后可以看到根目录下多了一个dist文件夹（webpack默认设置好的，后面会讲如何改变），里面有一个main.js文件，这个文件就是经过webpack处理后的index.js。 然后我们修改一下index.html的代码 1&lt;script src=\"./dist/main.js\"&gt;&lt;/script&gt; 这下浏览器就能正常识别html中的js文件了，到这里为止理解webpack是一个模块打包器应该不是很难了吧。webpack将模块componentA和componentB打包生成了最后的main.js。 webpack配置文件webpack的配置文件名默认是webpack.config.js，当然我们也可以指定配置文件。 开始之前我们先修改一下项目目录 webpacktest ├── index.html ├── package-lock.json ├── package.json ├── src │ ├── componentA.js │ ├── componentB.js │ └── index.js └── webpack.config.js 在项目根目录下新建配置文件webpack.config.js： 123456789101112const path = require('path');module.exports = &#123; mode: 'development', // 默认为production entry: &#123; main: './src/index.js' // 打包入口文件 &#125;, output: &#123; // 输出文件配置 filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 上面引用的path是node中的一个模块，__dirname表示webpack.config.js所在的目录。 entry可以简写为entry: ‘./src/index.js’ mode中的development和production有什么区别呢 我们看一下打包出来的文件bundle.js就知道了，production模式下的代码是一整行的，体积更小。而development模式下的代码不是一整行的有利于调试。 node path的 更多 执行下面命令后即可完成打包，效果和上一节一样 1npx webpack 当然也可以使用自定义配置文件 1npx webpack --config 自定义配置文件 写过项目的小伙伴应该都发现平时都是使用npm run xxx来打包项目的，下面就来介绍一下如何配置 修改package.json文件中的script 123\"scripts\": &#123; \"build\": \"webpack\"&#125;, 这样就可以通过npm run build来进行打包了，不过看过第一节的小伙伴肯定有疑问了，这样配置会不会使用全局的webpack去进行打包呢🙄，其实并不会，这里npm script命令会在项目的node_modules文件中去寻找webpack并执行。 打包好后我们打开index.html看看，发现是会报错的，这里注意：我们要手动把index.html移动到dist目录下并修改一下js路径，因为webpack并没有将index.html打包到dist目录下。 1&lt;script src=\"./bundle.js\"&gt;&lt;/script&gt; 这下再运行index.html就没有任何问题了。🎉","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"react博客-egg-jwt实现登录系统","slug":"react博客-egg-jwt实现登录系统","date":"2020-05-13T08:11:11.000Z","updated":"2020-05-13T08:11:11.000Z","comments":true,"path":"2020/05/13/react博客-egg-jwt实现登录系统/","link":"","permalink":"https://alanwang.site/2020/05/13/react%E5%8D%9A%E5%AE%A2-egg-jwt%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/","excerpt":"react博客系列文章","text":"react博客系列文章 何为jwtegg-jwt安装egg-jwtyarn add egg-jwt 配置egg-jwt 配置config/plugin.js文件 1234exports.jwt = &#123; enable: true, package: 'egg-jwt',&#125;; 配置config/config.default.js文件 1234// 自己设定的密钥，用于对信息进行签名config.jwt = &#123; secret: 'xxxxxx',&#125;; 实例后台实现登录操作返回token 路由层 在第二个参数上加上jwt即可实现对该路由的鉴权 下面的jwt是自定义的中间件auth.js，该文件在下一部分介绍 12345678910111213'use strict';/** * @param &#123;Egg.Application&#125; app - egg application */module.exports = app =&gt; &#123; const &#123; router, controller, middleware, config &#125; = app; const &#123; admin &#125; = controller.admin; const jwt = middleware.auth(config.jwt); router.post('/admin/login', admin.login); // 需要鉴权的路由再第二个参数上加上jwt router.get('/admin/get_type_list', jwt, admin.getTypeList);&#125;; controller层 使用jwt.sign(加密数据, 密钥, [options, callback]) 来生成token 相关配置可以查看jsonwebtoken 12345678910111213141516171819async login() &#123; const &#123; app, ctx &#125; = this; const &#123; username, password &#125; = ctx.request.body; const checkValidate = await ctx.service.admin.admin.checkUserValidate(username, password); if (checkValidate) &#123; // 将信息使用jwt进行签名加密生成token，expiresIn（token有效时间） const token = app.jwt.sign(&#123; username, password &#125;, app.config.jwt.secret, &#123; expiresIn: '2h' &#125;); ctx.body = &#123; code: '0001', msg: '登录成功', token, &#125;; &#125; else &#123; ctx.body = &#123; code: '0002', msg: '用户名或者密码错误，请重试！', &#125;; &#125;&#125; service层 1234async checkUserValidate(username, password) &#123; const isValidate = await this.app.mysql.get('admin', &#123; username, password &#125;); return !!isValidate;&#125; 使用postman进行测试 将生成的token返回给前台后使用localStorage.setItem把token保存到本地 前台传递token进行鉴权封装axios新建axios文件对axio进行封装，通过axios的拦截器来实现每次请求时自动在headers上携带token数据到后台，后台使用jwt.verify来检验token的正确性 axios.js 12345678910111213141516171819import axios from 'axios';axios.interceptors.request.use(config =&gt; &#123; // 登录成功后保存在本地的token const token = localStorage.getItem('token'); config.headers.Authorization = `Bearer $&#123;token&#125;`; return config;&#125;);axios.interceptors.response.use(response =&gt; &#123; // code是后台接口设置的 const &#123; code &#125; = response.data; if (code === '0003' || code === '0004') &#123; window.location.href = '/login'; &#125; return response;&#125;);export default axios; 封装好后，之后都使用该封装好后的axios进行请求。 后台校验处理auth.js 1234567891011121314151617181920212223242526272829303132'use strict';module.exports = options =&gt; &#123; return async function auth(ctx, next) &#123; // 获取前台通过axios封装后穿过来的token const token = ctx.header.authorization; if (token) &#123; try &#123; // 验证并对token进行解码 const decode = ctx.app.jwt.verify(token.split(' ')[1], options.secret); console.log(decode); await next(); &#125; catch (error) &#123; console.log(error.name); if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') &#123; // 这里的错误有许多种情况：1.token错误，2.token过期... 这里统一处理为鉴权失败 ctx.body = &#123; code: '0003', msg: '用户鉴权失败，请重新登录', &#125;; &#125; else &#123; throw error; &#125; &#125; &#125; else &#123; ctx.body = &#123; code: '0004', msg: '您没有登录，请先登录', &#125;; &#125; &#125;;&#125;; 后台通过/middleware/auth.js中间件来实现给需要鉴权的接口进行鉴权，通过对前台传过来的token数据进行验证jwt.verify来识别登录状态。对JsonWebTokenError错误统一处理，应为auth.js作为中间件，所以接口中出现的其他错误也会在这里被catch到，对于不是JsonWebTokenError的错误，直接把错误抛出去。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"},{"name":"ReactHook","slug":"ReactHook","permalink":"https://alanwang.site/tags/ReactHook/"},{"name":"jwt","slug":"jwt","permalink":"https://alanwang.site/tags/jwt/"}]},{"title":"react博客-项目部署","slug":"react博客-项目部署","date":"2020-05-13T07:51:16.000Z","updated":"2020-05-13T07:51:16.000Z","comments":true,"path":"2020/05/13/react博客-项目部署/","link":"","permalink":"https://alanwang.site/2020/05/13/react%E5%8D%9A%E5%AE%A2-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/","excerpt":"阿里云最近推出了一个“在家实践活动”，免费领取半年的服务器，真香。领取地址","text":"阿里云最近推出了一个“在家实践活动”，免费领取半年的服务器，真香。领取地址 购买阿里云服务器购买完成后会得到一个公网ip 下载软件putty来连接我们刚才购买的服务器，只需输入公网ip点击open即可 在命令行中输入用户名root和密码得到Welcome to Alibaba Cloud Elastic Compute Service !即完成了连接。 使用宝塔进行管理https://www.bt.cn/bbs/thread-19376-1-1.html 连接成功服务器后在命令行输入(Centos系统，其他系统查看上面网址)，复制按下鼠标右键完成宝塔的安装 1yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh 安装成功后会返回一个端口号为8888的网站以及账号和密码： 访问该地址，这个时候网站时不能访问的，因为远程服务器没有开放8888端口。 设置教程： https://www.bt.cn/bbs/thread-2897-1-1.html 登录成功后安装mysql和nginx（之后几乎所有的操作都在宝塔上进行） 需要安装软件 php环境（用于phpmyadmin） phpMyAdmin（用于管理mysql数据库） PM2（自带node环境） nginx 开放80(http)端口访问服务器在阿里云服务器管理控制台安全组中设置 设置后就可以通过公网ip访问服务器了 部署项目切换镜像源安装nrm（用来管理npm镜像源的工具）npm install -g nrm 常用命令 nrm ls 查看所有源地址 nrm use taobao 切换为淘宝镜像源 nrm add [name] [url] 添加源地址 通过git克隆代码到服务器把代码clone到服务器 打包项目并且部署 部署前台页面（next.js） yarn build yarn start 或者用PM2进行进程守护（待研究） 部署后台接口（egg.js） npm start 部署后台管理系统 直接npm build然后使用nginx进行代理 导入mysql数据出错在导入本地mysql文件时遇到了一些错误，参考文章： https://www.jianshu.com/p/788dceb93eff Linux查看端口号占用情况以及杀进程命令 netstart -anp（查看端口占用情况） lsof -i:8080（查看8080端口占用情况） kill -9 1234（杀PID=1234进程）","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"},{"name":"部署","slug":"部署","permalink":"https://alanwang.site/tags/%E9%83%A8%E7%BD%B2/"},{"name":"阿里云","slug":"阿里云","permalink":"https://alanwang.site/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}]},{"title":"测试主题","slug":"test1","date":"2020-05-13T01:19:17.000Z","updated":"2020-05-13T07:19:17.000Z","comments":true,"path":"2020/05/13/test1/","link":"","permalink":"https://alanwang.site/2020/05/13/test1/","excerpt":"这里是摘要","text":"这里是摘要 这里是正文 123456789101112131415161718192021222324252627title: 测试主题date: 2020-05-13 09:19:17top: truecategories: 测试分类tags: 测试标签author: name: 测试作者 avatar: https:&#x2F;&#x2F;gitee.com&#x2F;alannum3&#x2F;MyImages&#x2F;raw&#x2F;master&#x2F;img&#x2F;20200508165134.pngmusic:# 文章音乐 server: netease # netease, tencent, kugou, xiami, baidu type: song # song, playlist, album, search, artist id: 16846091 thumbnail:# 文章缩略图https:&#x2F;&#x2F;gitee.com&#x2F;alannum3&#x2F;MyImages&#x2F;raw&#x2F;master&#x2F;img&#x2F;20200508165134.png# 归档页面对应文章图标icons: [fas fa-fire red, fas fa-star green]meta:# 文章底部按钮 footer: [btns]btns: repo: https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis bug: https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis&#x2F;issues&#x2F; doubt: https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis&#x2F;issues&#x2F; idea: https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis&#x2F;issues&#x2F;cover: false #是否显示封面图 h1h2h31代码块 tab1tab2这里面写内容，支持的语法格式有限，请尽量不要写太过复杂的东西。","categories":[{"name":"测试分类","slug":"测试分类","permalink":"https://alanwang.site/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"测试标签","slug":"测试标签","permalink":"https://alanwang.site/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"}]},{"title":"Typora+PicGo+Gitee（书写博客神器）","slug":"Typora-PicGo-Gitee（书写博客神器）","date":"2020-05-12T13:06:52.000Z","updated":"2020-05-15T12:49:17.000Z","comments":true,"path":"2020/05/12/Typora-PicGo-Gitee（书写博客神器）/","link":"","permalink":"https://alanwang.site/2020/05/12/Typora-PicGo-Gitee%EF%BC%88%E4%B9%A6%E5%86%99%E5%8D%9A%E5%AE%A2%E7%A5%9E%E5%99%A8%EF%BC%89/","excerpt":"写博客，难免会随手截图来解释博客中的一些知识点或者内容。当高高兴兴地在本地电脑写完博客后将它上传之后发现所有图片都浏览不了了，这其实就是因为图片都保存在本地了。为了解决这个问题，从长远和财力来考虑，我使用了gitee搭配开源项目PicGo来做图床生成在线图片链接，这样无论在哪都能畅通查看图片了。而不使用github主要是国内访问速度是非常地慢。","text":"写博客，难免会随手截图来解释博客中的一些知识点或者内容。当高高兴兴地在本地电脑写完博客后将它上传之后发现所有图片都浏览不了了，这其实就是因为图片都保存在本地了。为了解决这个问题，从长远和财力来考虑，我使用了gitee搭配开源项目PicGo来做图床生成在线图片链接，这样无论在哪都能畅通查看图片了。而不使用github主要是国内访问速度是非常地慢。 参考文章：https://blog.csdn.net/disILLL/article/details/104944710 开搞软件版本 typora 0.9.86 PicGo 2.2.2 创建gitee仓库在gitee账户中创建一个公开的仓库用来保存图片 PicGo配置这边安装有一个巨坑，不要安装再Programe Files目录下面，切记 安装gitee-uploader插件 安装完后配置gitee token在自己的gitee中创建 点击commit生成token，将token填入PicGo中点击确定即可。 检查一下端口号是不是36677，这是我踩过的一个坑 配置Typora实现插入图片自动上传新版本的Typora已经支持图片上传功能，具体配置如下（文件-&gt;偏好设置）： 测试可以看到这里图片的链接是之前在gitee中创建的用来保存图片的Repository的地址了 哈哈，成功了，这样效率就提高了许多了。","categories":[{"name":"效率工具","slug":"效率工具","permalink":"https://alanwang.site/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Typora","slug":"Typora","permalink":"https://alanwang.site/tags/Typora/"},{"name":"工具","slug":"工具","permalink":"https://alanwang.site/tags/%E5%B7%A5%E5%85%B7/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"记录生活","slug":"记录生活","permalink":"https://alanwang.site/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"},{"name":"2020","slug":"记录生活/2020","permalink":"https://alanwang.site/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/2020/"},{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://alanwang.site/categories/Hexo%E5%8D%9A%E5%AE%A2/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"},{"name":"测试分类","slug":"测试分类","permalink":"https://alanwang.site/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"},{"name":"效率工具","slug":"效率工具","permalink":"https://alanwang.site/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"},{"name":"记录生活","slug":"记录生活","permalink":"https://alanwang.site/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"},{"name":"Hexo","slug":"Hexo","permalink":"https://alanwang.site/tags/Hexo/"},{"name":"valine","slug":"valine","permalink":"https://alanwang.site/tags/valine/"},{"name":"评论系统","slug":"评论系统","permalink":"https://alanwang.site/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"},{"name":"ReactHook","slug":"ReactHook","permalink":"https://alanwang.site/tags/ReactHook/"},{"name":"jwt","slug":"jwt","permalink":"https://alanwang.site/tags/jwt/"},{"name":"部署","slug":"部署","permalink":"https://alanwang.site/tags/%E9%83%A8%E7%BD%B2/"},{"name":"阿里云","slug":"阿里云","permalink":"https://alanwang.site/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"测试标签","slug":"测试标签","permalink":"https://alanwang.site/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"},{"name":"Typora","slug":"Typora","permalink":"https://alanwang.site/tags/Typora/"},{"name":"工具","slug":"工具","permalink":"https://alanwang.site/tags/%E5%B7%A5%E5%85%B7/"}]}