{"meta":{"title":"Alan|前端博客","subtitle":"","description":"一个专注于前端开发的小白，分享前端开发知识","author":"Alan","url":"https://alanwang.site","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-05-13T09:03:12.444Z","updated":"2020-05-13T09:03:12.444Z","comments":true,"path":"404.html","permalink":"https://alanwang.site/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2020-05-14T12:42:42.500Z","updated":"2020-05-14T12:42:42.500Z","comments":true,"path":"about/index.html","permalink":"https://alanwang.site/about/index.html","excerpt":"","text":"Alan 待完善"},{"title":"所有分类","date":"2020-05-14T12:46:25.030Z","updated":"2020-05-14T12:46:25.030Z","comments":true,"path":"categories/index.html","permalink":"https://alanwang.site/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-14T13:02:13.019Z","updated":"2020-05-14T13:02:13.019Z","comments":true,"path":"list/index.html","permalink":"https://alanwang.site/list/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-05-14T13:25:42.778Z","updated":"2020-05-14T13:25:42.778Z","comments":true,"path":"friends/index.html","permalink":"https://alanwang.site/friends/index.html","excerpt":"","text":"要添加友链的朋友按照下面格式给我留言😘 12345678items:- name: # 博客名 必填 avatar: # 头像链接 必填 url: # 博客链接 必填 backgroundColor: &#39;#3E74C9&#39; # 卡片背景颜色 textColor: &#39;#fff&#39; # 卡片文字颜色 tags: [标签1, 标签2] # 标签 desc: 描述文字"},{"title":"所有标签","date":"2020-05-14T12:58:35.975Z","updated":"2020-05-14T12:58:35.975Z","comments":true,"path":"tags/index.html","permalink":"https://alanwang.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"valine国际版邮件回复","slug":"valine国际版邮件回复","date":"2020-05-16T08:02:54.000Z","updated":"2020-05-16T08:02:54.000Z","comments":true,"path":"2020/05/16/valine国际版邮件回复/","link":"","permalink":"https://alanwang.site/2020/05/16/valine%E5%9B%BD%E9%99%85%E7%89%88%E9%82%AE%E4%BB%B6%E5%9B%9E%E5%A4%8D/","excerpt":"本博客评论系统使用了valine国际版，支持评论邮件提醒","text":"本博客评论系统使用了valine国际版，支持评论邮件提醒 准备工作注册一个LeanCloud国际版账号（国内的好像需要绑定域名和备案）注册地址👉https://console.leancloud.app/login.html#/signup 之后创建一个应用，名字随便取 在设置中找到应用keys,把appid和appkey复制到hexo对应的配置当中。由于本文重点讲邮件回复功能，这一部分就不多过赘述了😝。直接进入正题。 修改邮件模板 12345&lt;p&gt;Hi, &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;p&gt;你在 &#123;&#123;appname&#125;&#125; 的评论收到了新的回复，请点击查看：&lt;/p&gt;&lt;p&gt;&lt;a href=\"https://alanwang.site\" style=\"display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;\"&gt;马上查看&lt;/a&gt;&lt;/p&gt; 部署valine-admin首先进行配置 更多配置参考：https://github.com/DesertsP/Valine-Admin 1https:&#x2F;&#x2F;github.com&#x2F;DesertsP&#x2F;Valine-Admin.git 网上的zhaojun1998版本我之前也试过，但是在国际版部署是会报错的，看错误信息应该是node版本太低了，而且就算部署成功了，后台也是登录不了的。这个版本我实测是没有问题的。 部署分支默认为master 点击部署即可 点击该链接访问后台管理系统（这里需要用户名和密码登录，需要到存储中的_User中自行创建） 这里只需要填写username、password、email即可，添加后在后台管理系统输入邮箱和密码就可以成功登录了。 设置定时唤醒 10 */30 7-23 * * ?","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://alanwang.site/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://alanwang.site/tags/Hexo/"},{"name":"valine","slug":"valine","permalink":"https://alanwang.site/tags/valine/"},{"name":"评论系统","slug":"评论系统","permalink":"https://alanwang.site/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"webpack4.0学习总结（二）","slug":"webpack4.0学习总结（二）","date":"2020-05-15T12:00:22.000Z","updated":"2020-05-16T05:33:00.000Z","comments":true,"path":"2020/05/15/webpack4.0学习总结（二）/","link":"","permalink":"https://alanwang.site/2020/05/15/webpack4.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"这节主要讲一讲一些常见的Loder的使用。包括file-loader、url-loader以及css-loader和style-loader。","text":"这节主要讲一讲一些常见的Loder的使用。包括file-loader、url-loader以及css-loader和style-loader。 Loaderfile-loader上一节简单介绍了webpack是什么，webpack是一个模块打包器，可以将es的模块文件进行打包。上一节我们只打包了js文件，那我们能不能打包其他类型的文件呢，先来试一试打包图片吧。 这里使用到了file-loader 1npm i file-loader -D index.jswebpack.config.js123456789101112131415// ES Moudule 模块化引入import ComponentB from './componentB';var root = document.getElementById('root');// CommonJs 模块引入var ComponentA = require('./componentA');var img1 = require('./IMG_3294.jpg');console.log(img1);var img = new Image();img.src = img1;root.append(img);new ComponentA();new ComponentB();12345678910111213141516171819202122const path = require('path');module.exports = &#123; mode: 'development', // 默认为production entry: &#123; main: './src/index.js' // 打包入口文件 &#125;, module: &#123; rules: [ &#123; test: /\\.jpg$/, use: &#123; loader: 'file-loader' &#125; &#125; ] &#125;, output: &#123; // 输出文件配置 filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; npm run build进行打包，我们看一下控制台打印出来的img1 这里可以看到img1是一个Module。 我们可以通过img1.default来获取路径或者直接通过import形式来引入，这样图片就成功得显示出来了😄 1import img1 from './IMG_3294.jpg' 通过这个例子可以知道了loader的大致作用方法了，通过test来匹配特定文件使用（use)特定的loader来对文件进行打包处理。 我们再看一下打包出来的文件 dist ├── a2099657cfcaf9f019ccf08e9dc8747d.jpg ├── bundle.js └── index.html 发现我们的图片名称被改变成了一长串字符，那我怎么让它不改变名字呢。这时候loader的options就派上用场了😎 1234567891011rules: [ &#123; test: /\\.(jpg|png)$/, use: &#123; loader: 'file-loader', options: &#123; name: '[name].[ext]' &#125; &#125; &#125;] 这里的[name]和[ext]是loader中的placeholder,分别表示文件的名字和后缀名，当然loader中还有很多的placeholder。 设置好后进行打包得到如下结果 dist ├── bundle.js ├── IMG_3294.jpg └── index.html 现在有一个问题，当我们的图片一旦多起来那全部打包放在根目录下拿岂不是很乱，这个时候就可以使用options中的output来规定经过loader处理后的输出路径了。 1234options: &#123; name: '[name].[ext]', outputPath: 'images/'&#125; 打包看一下结果成功👌，运行一下html文件图片也可以正常显示。 dist ├── bundle.js ├── images │ └── IMG_3294.jpg └── index.html 到这里我们就了解了file-loader的基本使用了。 url-loaderurl-loader也可以打包文件，但是和file-loader不同的是，它会将我们的图片转化成base64编码，那如果我不想转化呢，我们可以使用options中的limit属性来限制文件在小于多少时转化成base64编码，一旦大于这个值打包出来的效果就和file-loader一样了。 看一下例子就清楚了 1npm i url-loader -D 这里准备两个图片，一个大小300k，一个大小7k webpack配置 123456789101112131415161718192021222324252627const path = require('path');module.exports = &#123; mode: 'development', // 默认为production entry: &#123; main: './src/index.js' // 打包入口文件 &#125;, module: &#123; rules: [ &#123; test: /\\.(jpg|png)$/, use: &#123; loader: 'url-loader', options: &#123; name: '[name].[ext]', outputPath: 'images/', limit: 10240 &#125; &#125; &#125; ] &#125;, output: &#123; // 输出文件配置 filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 看一下打包后的文件 dist ├── bundle.js ├── images │ └── 300k.jpg └── index.html 结果是大于10240的300k.jpg文件被以图片形式打包出来了，那7k.jpg文件去哪了呢，我们在bundle.js文件中可以找到了它，它被转化成了base64编码。 1data:image&#x2F;jpeg;base64,&#x2F;9j&#x2F;4AAQSkZJRgABAQEAYABgAAD... 当然limit也可以设置为true/false，更多配置 我在操作中发现了如果html中没有使用到7k.jpg，url-loader是不会对它进行打包的。 这里并不建议把大文件转化为base64，这样会增加bundle.js的体积，对项目优化不太友好 样式文件接着上面的例子，我现在想要为页面中的图片添加一些样式 index.jsindex.css123456789101112131415161718// ES Moudule 模块化引入import ComponentB from './componentB';import './index.css';var root = document.getElementById('root');// CommonJs 模块引入var ComponentA = require('./componentA');import img1 from './300k.jpg';console.log(img1);var img = new Image();img.src = img1;img.classList.add('circle');root.append(img);new ComponentA();new ComponentB();12345.circle &#123; width: 100px; height: 100px; border-radius: 50px;&#125; 现在我想要打包css文件该怎么办呢😶，我们要用到两个loader，css-loader和style-loader 安装 1npm i style-loader css-loader -D webpack配置 1234&#123; test: /\\.css$/, use: ['style-loader', 'css-loader']&#125; 打包成功，打开网页看一看效果生效了 这里简单介绍一下style-loader和css-loader的作用，首先它们执行有先后顺序的，先使用css-loader对css文件进行打包，再用style-loader把打包后的css文件内容以&lt;style&gt;&lt;/style&gt;加到页面的header中。 有时候我们要为css加上浏览器引擎前缀-webkit，这里有一个loader可以帮我们完成postcss-loader 安装 1npm i postcss-loader autoprefixer -D webpack配置 123456789101112&#123; test: /\\.css$/, use: ['style-loader', 'css-loader', &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', pulgins: [ require('autoprefixer') ] &#125; &#125;],&#125;, 这里貌似有点问题，后期我再研究研究。 扩展css模块化先看一个场景 index.jscomponentA.js123456789101112import './index.css';import img1 from './300k.jpg';import ComponentA from './componentA';var root = document.getElementById('root');var img = new Image();img.src = img1;img.classList.add('circle');root.append(img);ComponentA();1234567891011import img1 from './300k.jpg';function ComponentA() &#123; var img = new Image(); img.src = img1; img.classList.add('circle'); var root = document.getElementById('root'); root.append(img);&#125;export default ComponentA; 我们看到circle样式同样作用在了componentA上了，也就是说circle已经等同于是全局样式了😥。还好我们可以通过配置css-loader的options来使用css的模块化来解决这个问题。 12345678910111213141516171819&#123; test: /\\.css$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; modules: true, &#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', pulgins: [require('autoprefixer')], &#125;, &#125;, ],&#125;, 配置好后我们在要使用样式的地方使用下面这种写法 123import circle from './index.css';img.classList.add(circle.circle); 这样我们再修改样式就不会影响到其他地方了。 css外部引入这里主要介绍css-loader的optionsimportLoaders。 我们在index.css文件中引入外部css文件 1@import './import.css'; 假设我们有以下几个loader处理css文件 [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;, &#39;postcss-loader&#39;] 当webpack处理index.css文件时按照postcss-loader-&gt;sass-loader-&gt;css-loader顺序来执行css文件的 当遇到@import时处理import.css时，如果不做处理的话，import.css将直接从css-loader开始处理的，那我想让它从postcss-loader从头处理的话就要设置imortLoaders数目了。 123456&#123; loader: 'css-loader', options: &#123; importLoaders: 1, &#125;&#125;, 这里的1表示处理@import引入的css文件是，先要被前面的1个loader处理，也就是import.css的处理顺序是sass-loader-&gt;css-loader-style-loader。 处理字体文件直接使用file-loader处理就可以了 webpack.config.jsindex.jsiconfont.css123456&#123; test: /\\.(eot|ttf|svg|woff)$/, use: &#123; loader: 'file-loader', &#125;,&#125;,12345import './font/iconfont.css';var root = document.getElementById('root');root.innerHTML = '&lt;div class=\"iconfont icon-smile\"&gt;&lt;/div&gt;'1234567891011121314151617181920@font-face &#123;font-family: \"iconfont\"; src: url('iconfont.eot?t=1589604469136'); /* IE9 */ src: url('iconfont.eot?t=1589604469136#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('data:application/x-font-woff2;charset=utf-8;base64,这里base64代码太长删除掉了') format('woff2'), url('iconfont.woff?t=1589604469136') format('woff'), url('iconfont.ttf?t=1589604469136') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url('iconfont.svg?t=1589604469136#iconfont') format('svg'); /* iOS 4.1- */&#125;.iconfont &#123; font-family: \"iconfont\" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.icon-smile:before &#123; content: \"\\e783\";&#125; ok!这章到此介绍。现在我们已经能够处理一些常见文件的打包了，对webpack的认识也应该算一个简单的入门了。😁","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"webpack4.0学习总结（一）","slug":"webpack4.0学习总结（一）","date":"2020-05-14T08:01:46.000Z","updated":"2020-05-14T08:01:46.000Z","comments":true,"path":"2020/05/14/webpack4.0学习总结（一）/","link":"","permalink":"https://alanwang.site/2020/05/14/webpack4.0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"这一篇文章主要简单介绍了webpack是什么以及webpack的一些简单配置，你只要跟着我敲完这些代码后一定会对webpack有一个基本的了解的。😎","text":"这一篇文章主要简单介绍了webpack是什么以及webpack的一些简单配置，你只要跟着我敲完这些代码后一定会对webpack有一个基本的了解的。😎 webpack是一个模块打包器 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 上面引用了webpack官网的一段介绍，我们可以简单的理解webpack是一个模块打包器，那什么是模块打包器呢？😂先看一个简单的例子 index.htmlindex.jscomponentA.jscomponentB.js123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;12345678910// ES Moudule 模块化引入import ComponentB from './componentB';var root = document.getElementById('root');// CommonJs 模块引入var ComponentA = require('./componentA');new ComponentA();new ComponentB();1234567function ComponentA() &#123; var componentA = document.createElement('div'); componentA.innerHTML = 'ComponentA'; root.append(componentA);&#125;module.exports = ComponentA;1234567function ComponentB() &#123; var componentB = document.createElement('div'); componentB.innerHTML = 'ComponentB'; root.append(componentB);&#125;export default ComponentB; 这里的模块可以理解成componentA和componentB，这种写法在vue和react中非常常见，写完这些文件后打开index.html文件，浏览器是会报错的。 Uncaught SyntaxError: Cannot use import statement outside a module 这是由于这里使用了es6中的模板引入的方式，浏览器是识别不了这种方式的，那怎么办呢？😥 这个时候webpack就派上用场了，首先初始化该项目 1npm init -y 初始化后会生成package.json文件 安装webpack-cli和webpack（不建议全局安装） 12npm install webpack-cli -Dnpm install webpack -S 安装固定版本的webpack 12npm install webpack@版本号npm info webpack &#x2F;&#x2F; 查看包信息 打包index.js 1npx webpack index.js 这里如果不使用npx的话node会默认在全局环境中找寻webpack，加上npx的话就会使用项目中安装的webpack来执行命令 打包后可以看到根目录下多了一个dist文件夹（webpack默认设置好的，后面会讲如何改变），里面有一个main.js文件，这个文件就是经过webpack处理后的index.js。 然后我们修改一下index.html的代码 1&lt;script src=\"./dist/main.js\"&gt;&lt;/script&gt; 这下浏览器就能正常识别html中的js文件了，到这里为止理解webpack是一个模块打包器应该不是很难了吧。webpack将模块componentA和componentB打包生成了最后的main.js。 webpack配置文件webpack的配置文件名默认是webpack.config.js，当然我们也可以指定配置文件。 开始之前我们先修改一下项目目录 webpacktest ├── index.html ├── package-lock.json ├── package.json ├── src │ ├── componentA.js │ ├── componentB.js │ └── index.js └── webpack.config.js 在项目根目录下新建配置文件webpack.config.js： 123456789101112const path = require('path');module.exports = &#123; mode: 'development', // 默认为production entry: &#123; main: './src/index.js' // 打包入口文件 &#125;, output: &#123; // 输出文件配置 filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125; 上面引用的path是node中的一个模块，__dirname表示webpack.config.js所在的目录。 entry可以简写为entry: ‘./src/index.js’ mode中的development和production有什么区别呢 我们看一下打包出来的文件bundle.js就知道了，production模式下的代码是一整行的，体积更小。而development模式下的代码不是一整行的有利于调试。 node path的 更多 执行下面命令后即可完成打包，效果和上一节一样 1npx webpack 当然也可以使用自定义配置文件 1npx webpack --config 自定义配置文件 写过项目的小伙伴应该都发现平时都是使用npm run xxx来打包项目的，下面就来介绍一下如何配置 修改package.json文件中的script 123\"scripts\": &#123; \"build\": \"webpack\"&#125;, 这样就可以通过npm run build来进行打包了，不过看过第一节的小伙伴肯定有疑问了，这样配置会不会使用全局的webpack去进行打包呢🙄，其实并不会，这里npm script命令会在项目的node_modules文件中去寻找webpack并执行。 打包好后我们打开index.html看看，发现是会报错的，这里注意：我们要手动把index.html移动到dist目录下并修改一下js路径，因为webpack并没有将index.html打包到dist目录下。 1&lt;script src=\"./bundle.js\"&gt;&lt;/script&gt; 这下再运行index.html就没有任何问题了。🎉","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"react博客-egg-jwt实现登录系统","slug":"react博客-egg-jwt实现登录系统","date":"2020-05-13T08:11:11.000Z","updated":"2020-05-13T08:11:11.000Z","comments":true,"path":"2020/05/13/react博客-egg-jwt实现登录系统/","link":"","permalink":"https://alanwang.site/2020/05/13/react%E5%8D%9A%E5%AE%A2-egg-jwt%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/","excerpt":"react博客系列文章","text":"react博客系列文章 何为jwtegg-jwt安装egg-jwtyarn add egg-jwt 配置egg-jwt 配置config/plugin.js文件 1234exports.jwt = &#123; enable: true, package: 'egg-jwt',&#125;; 配置config/config.default.js文件 1234// 自己设定的密钥，用于对信息进行签名config.jwt = &#123; secret: 'xxxxxx',&#125;; 实例后台实现登录操作返回token 路由层 在第二个参数上加上jwt即可实现对该路由的鉴权 下面的jwt是自定义的中间件auth.js，该文件在下一部分介绍 12345678910111213'use strict';/** * @param &#123;Egg.Application&#125; app - egg application */module.exports = app =&gt; &#123; const &#123; router, controller, middleware, config &#125; = app; const &#123; admin &#125; = controller.admin; const jwt = middleware.auth(config.jwt); router.post('/admin/login', admin.login); // 需要鉴权的路由再第二个参数上加上jwt router.get('/admin/get_type_list', jwt, admin.getTypeList);&#125;; controller层 使用jwt.sign(加密数据, 密钥, [options, callback]) 来生成token 相关配置可以查看jsonwebtoken 12345678910111213141516171819async login() &#123; const &#123; app, ctx &#125; = this; const &#123; username, password &#125; = ctx.request.body; const checkValidate = await ctx.service.admin.admin.checkUserValidate(username, password); if (checkValidate) &#123; // 将信息使用jwt进行签名加密生成token，expiresIn（token有效时间） const token = app.jwt.sign(&#123; username, password &#125;, app.config.jwt.secret, &#123; expiresIn: '2h' &#125;); ctx.body = &#123; code: '0001', msg: '登录成功', token, &#125;; &#125; else &#123; ctx.body = &#123; code: '0002', msg: '用户名或者密码错误，请重试！', &#125;; &#125;&#125; service层 1234async checkUserValidate(username, password) &#123; const isValidate = await this.app.mysql.get('admin', &#123; username, password &#125;); return !!isValidate;&#125; 使用postman进行测试 将生成的token返回给前台后使用localStorage.setItem把token保存到本地 前台传递token进行鉴权封装axios新建axios文件对axio进行封装，通过axios的拦截器来实现每次请求时自动在headers上携带token数据到后台，后台使用jwt.verify来检验token的正确性 axios.js 12345678910111213141516171819import axios from 'axios';axios.interceptors.request.use(config =&gt; &#123; // 登录成功后保存在本地的token const token = localStorage.getItem('token'); config.headers.Authorization = `Bearer $&#123;token&#125;`; return config;&#125;);axios.interceptors.response.use(response =&gt; &#123; // code是后台接口设置的 const &#123; code &#125; = response.data; if (code === '0003' || code === '0004') &#123; window.location.href = '/login'; &#125; return response;&#125;);export default axios; 封装好后，之后都使用该封装好后的axios进行请求。 后台校验处理auth.js 1234567891011121314151617181920212223242526272829303132'use strict';module.exports = options =&gt; &#123; return async function auth(ctx, next) &#123; // 获取前台通过axios封装后穿过来的token const token = ctx.header.authorization; if (token) &#123; try &#123; // 验证并对token进行解码 const decode = ctx.app.jwt.verify(token.split(' ')[1], options.secret); console.log(decode); await next(); &#125; catch (error) &#123; console.log(error.name); if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') &#123; // 这里的错误有许多种情况：1.token错误，2.token过期... 这里统一处理为鉴权失败 ctx.body = &#123; code: '0003', msg: '用户鉴权失败，请重新登录', &#125;; &#125; else &#123; throw error; &#125; &#125; &#125; else &#123; ctx.body = &#123; code: '0004', msg: '您没有登录，请先登录', &#125;; &#125; &#125;;&#125;; 后台通过/middleware/auth.js中间件来实现给需要鉴权的接口进行鉴权，通过对前台传过来的token数据进行验证jwt.verify来识别登录状态。对JsonWebTokenError错误统一处理，应为auth.js作为中间件，所以接口中出现的其他错误也会在这里被catch到，对于不是JsonWebTokenError的错误，直接把错误抛出去。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"},{"name":"ReactHook","slug":"ReactHook","permalink":"https://alanwang.site/tags/ReactHook/"},{"name":"jwt","slug":"jwt","permalink":"https://alanwang.site/tags/jwt/"}]},{"title":"react博客-项目部署","slug":"react博客-项目部署","date":"2020-05-13T07:51:16.000Z","updated":"2020-05-13T07:51:16.000Z","comments":true,"path":"2020/05/13/react博客-项目部署/","link":"","permalink":"https://alanwang.site/2020/05/13/react%E5%8D%9A%E5%AE%A2-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/","excerpt":"阿里云最近推出了一个“在家实践活动”，免费领取半年的服务器，真香。领取地址","text":"阿里云最近推出了一个“在家实践活动”，免费领取半年的服务器，真香。领取地址 购买阿里云服务器购买完成后会得到一个公网ip 下载软件putty来连接我们刚才购买的服务器，只需输入公网ip点击open即可 在命令行中输入用户名root和密码得到Welcome to Alibaba Cloud Elastic Compute Service !即完成了连接。 使用宝塔进行管理https://www.bt.cn/bbs/thread-19376-1-1.html 连接成功服务器后在命令行输入(Centos系统，其他系统查看上面网址)，复制按下鼠标右键完成宝塔的安装 1yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh 安装成功后会返回一个端口号为8888的网站以及账号和密码： 访问该地址，这个时候网站时不能访问的，因为远程服务器没有开放8888端口。 设置教程： https://www.bt.cn/bbs/thread-2897-1-1.html 登录成功后安装mysql和nginx（之后几乎所有的操作都在宝塔上进行） 需要安装软件 php环境（用于phpmyadmin） phpMyAdmin（用于管理mysql数据库） PM2（自带node环境） nginx 开放80(http)端口访问服务器在阿里云服务器管理控制台安全组中设置 设置后就可以通过公网ip访问服务器了 部署项目切换镜像源安装nrm（用来管理npm镜像源的工具）npm install -g nrm 常用命令 nrm ls 查看所有源地址 nrm use taobao 切换为淘宝镜像源 nrm add [name] [url] 添加源地址 通过git克隆代码到服务器把代码clone到服务器 打包项目并且部署 部署前台页面（next.js） yarn build yarn start 或者用PM2进行进程守护（待研究） 部署后台接口（egg.js） npm start 部署后台管理系统 直接npm build然后使用nginx进行代理 导入mysql数据出错在导入本地mysql文件时遇到了一些错误，参考文章： https://www.jianshu.com/p/788dceb93eff Linux查看端口号占用情况以及杀进程命令 netstart -anp（查看端口占用情况） lsof -i:8080（查看8080端口占用情况） kill -9 1234（杀PID=1234进程）","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"},{"name":"部署","slug":"部署","permalink":"https://alanwang.site/tags/%E9%83%A8%E7%BD%B2/"},{"name":"阿里云","slug":"阿里云","permalink":"https://alanwang.site/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}]},{"title":"测试主题","slug":"test1","date":"2020-05-13T01:19:17.000Z","updated":"2020-05-13T07:19:17.000Z","comments":true,"path":"2020/05/13/test1/","link":"","permalink":"https://alanwang.site/2020/05/13/test1/","excerpt":"这里是摘要","text":"这里是摘要 这里是正文 123456789101112131415161718192021222324252627title: 测试主题date: 2020-05-13 09:19:17top: truecategories: 测试分类tags: 测试标签author: name: 测试作者 avatar: https:&#x2F;&#x2F;gitee.com&#x2F;alannum3&#x2F;MyImages&#x2F;raw&#x2F;master&#x2F;img&#x2F;20200508165134.pngmusic:# 文章音乐 server: netease # netease, tencent, kugou, xiami, baidu type: song # song, playlist, album, search, artist id: 16846091 thumbnail:# 文章缩略图https:&#x2F;&#x2F;gitee.com&#x2F;alannum3&#x2F;MyImages&#x2F;raw&#x2F;master&#x2F;img&#x2F;20200508165134.png# 归档页面对应文章图标icons: [fas fa-fire red, fas fa-star green]meta:# 文章底部按钮 footer: [btns]btns: repo: https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis bug: https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis&#x2F;issues&#x2F; doubt: https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis&#x2F;issues&#x2F; idea: https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis&#x2F;issues&#x2F;cover: false #是否显示封面图 h1h2h31代码块 tab1tab2这里面写内容，支持的语法格式有限，请尽量不要写太过复杂的东西。","categories":[{"name":"测试分类","slug":"测试分类","permalink":"https://alanwang.site/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"测试标签","slug":"测试标签","permalink":"https://alanwang.site/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"}]},{"title":"Typora+PicGo+Gitee（书写博客神器）","slug":"Typora-PicGo-Gitee（书写博客神器）","date":"2020-05-12T13:06:52.000Z","updated":"2020-05-15T12:49:17.000Z","comments":true,"path":"2020/05/12/Typora-PicGo-Gitee（书写博客神器）/","link":"","permalink":"https://alanwang.site/2020/05/12/Typora-PicGo-Gitee%EF%BC%88%E4%B9%A6%E5%86%99%E5%8D%9A%E5%AE%A2%E7%A5%9E%E5%99%A8%EF%BC%89/","excerpt":"写博客，难免会随手截图来解释博客中的一些知识点或者内容。当高高兴兴地在本地电脑写完博客后将它上传之后发现所有图片都浏览不了了，这其实就是因为图片都保存在本地了。为了解决这个问题，从长远和财力来考虑，我使用了gitee搭配开源项目PicGo来做图床生成在线图片链接，这样无论在哪都能畅通查看图片了。而不使用github主要是国内访问速度是非常地慢。","text":"写博客，难免会随手截图来解释博客中的一些知识点或者内容。当高高兴兴地在本地电脑写完博客后将它上传之后发现所有图片都浏览不了了，这其实就是因为图片都保存在本地了。为了解决这个问题，从长远和财力来考虑，我使用了gitee搭配开源项目PicGo来做图床生成在线图片链接，这样无论在哪都能畅通查看图片了。而不使用github主要是国内访问速度是非常地慢。 参考文章：https://blog.csdn.net/disILLL/article/details/104944710 开搞软件版本 typora 0.9.86 PicGo 2.2.2 创建gitee仓库在gitee账户中创建一个公开的仓库用来保存图片 PicGo配置这边安装有一个巨坑，不要安装再Programe Files目录下面，切记 安装gitee-uploader插件 安装完后配置gitee token在自己的gitee中创建 点击commit生成token，将token填入PicGo中点击确定即可。 检查一下端口号是不是36677，这是我踩过的一个坑 配置Typora实现插入图片自动上传新版本的Typora已经支持图片上传功能，具体配置如下（文件-&gt;偏好设置）： 测试可以看到这里图片的链接是之前在gitee中创建的用来保存图片的Repository的地址了 哈哈，成功了，这样效率就提高了许多了。","categories":[{"name":"效率工具","slug":"效率工具","permalink":"https://alanwang.site/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://alanwang.site/tags/Typora/"},{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"工具","slug":"工具","permalink":"https://alanwang.site/tags/%E5%B7%A5%E5%85%B7/"}]}],"categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://alanwang.site/categories/Hexo%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"},{"name":"测试分类","slug":"测试分类","permalink":"https://alanwang.site/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"},{"name":"效率工具","slug":"效率工具","permalink":"https://alanwang.site/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://alanwang.site/tags/Hexo/"},{"name":"valine","slug":"valine","permalink":"https://alanwang.site/tags/valine/"},{"name":"评论系统","slug":"评论系统","permalink":"https://alanwang.site/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"},{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"},{"name":"ReactHook","slug":"ReactHook","permalink":"https://alanwang.site/tags/ReactHook/"},{"name":"jwt","slug":"jwt","permalink":"https://alanwang.site/tags/jwt/"},{"name":"部署","slug":"部署","permalink":"https://alanwang.site/tags/%E9%83%A8%E7%BD%B2/"},{"name":"阿里云","slug":"阿里云","permalink":"https://alanwang.site/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"测试标签","slug":"测试标签","permalink":"https://alanwang.site/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"},{"name":"Typora","slug":"Typora","permalink":"https://alanwang.site/tags/Typora/"},{"name":"工具","slug":"工具","permalink":"https://alanwang.site/tags/%E5%B7%A5%E5%85%B7/"}]}