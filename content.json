{"meta":{"title":"Alan|前端博客","subtitle":"","description":"一个专注于前端开发的小白，分享前端开发知识","author":"Alan","url":"https://alanwang.site","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-09-27T07:06:20.427Z","updated":"2020-09-27T07:06:20.427Z","comments":true,"path":"404.html","permalink":"https://alanwang.site/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2020-09-27T07:06:22.762Z","updated":"2020-09-27T07:06:22.762Z","comments":true,"path":"categories/index.html","permalink":"https://alanwang.site/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2020-10-26T04:22:11.873Z","updated":"2020-10-26T04:22:11.873Z","comments":true,"path":"about/index.html","permalink":"https://alanwang.site/about/index.html","excerpt":"","text":"Alan 待完善"},{"title":"我的朋友们","date":"2020-09-27T07:06:23.724Z","updated":"2020-09-27T07:06:23.724Z","comments":true,"path":"friends/index.html","permalink":"https://alanwang.site/friends/index.html","excerpt":"","text":"要添加友链的朋友按照下面格式给我留言😘 items: - name: # 博客名 必填 avatar: # 头像链接 必填 url: # 博客链接 必填 backgroundColor: &#39;#3E74C9&#39; # 卡片背景颜色 textColor: &#39;#fff&#39; # 卡片文字颜色 tags: [标签1, 标签2] # 标签 desc: 描述文字"},{"title":"","date":"2020-09-27T07:06:23.314Z","updated":"2020-09-27T07:06:23.314Z","comments":true,"path":"list/index.html","permalink":"https://alanwang.site/list/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-09-27T07:06:22.821Z","updated":"2020-09-27T07:06:22.821Z","comments":true,"path":"tags/index.html","permalink":"https://alanwang.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记一次Next.js搭建之旅","slug":"记一次Next-js搭建之旅","date":"2020-11-12T09:04:58.000Z","updated":"2020-11-12T09:04:58.000Z","comments":true,"path":"posts/6af865/","link":"","permalink":"https://alanwang.site/posts/6af865/","excerpt":"这段时间工作要求将之前的vue的H5活动页面转移到Next.js下面，经过一段时间的研究，总结出了下面的内容。","text":"这段时间工作要求将之前的vue的H5活动页面转移到Next.js下面，经过一段时间的研究，总结出了下面的内容。 什么Next.js基于React的SSR（服务端渲染框架） SSR &amp; CSR 参考链接：https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8 The main difference is that for SSR your server’s response to the browser is the HTML of your page that is ready to be rendered, while for CSR the browser gets a pretty empty document with links to your javascript. That means your browser will start rendering the HTML from your server without having to wait for all the JavaScript to be downloaded and executed. In both cases, React will need to be downloaded and go through the same process of building a virtual dom and attaching events to make the page interactive — but for SSR, the user can start viewing the page while all of that is happening. For the CSR world, you need to wait for all of the above to happen and then have the virtual dom moved to the browser dom for the page to be viewable. Next.js的优点 更好的SEO 更快的首屏渲染速度 Next.js 基础(与Rect开发的不同之处) https://www.nextjs.cn/learn/basics/create-nextjs-app?utm_source=next-site&amp;utm_medium=nav-cta&amp;utm_campaign=next-website 路由映射 在 Next.js 中，一个 page（页面） 就是一个从 .js、jsx、.ts 或 .tsx 文件导出（export）的 React 组件 ，这些文件存放在 pages 目录下。每个 page（页面）都使用其文件名作为路由（route）。 pages/about.js/jsx/ts/tsx → /about pages/dashboard/settings/username.js → /dashboard/settings/username 自带路由：next/router next/link使用与react-router类似，包括编程式跳转router.push以及组件式跳转&lt;Link href=&quot;/about&quot;&gt;&lt;a&gt;click me&lt;/a&gt;&lt;/Link&gt; import { useRouter } from &#39;next/router&#39;; const router = useRouter(); router.push({ pathname: &#39;/activities/experience-lesson/course-info&#39;, query: { ...queryData, isFree: 0 } }); router.push(&#39;/about&#39;) 渲染方式预渲染 静态生成（Static Generation）（HTML重用、build生成） 服务器端渲染（Server-side Rendering）（每次请求生成的HTML不同、用户请求时生成） 相关API 静态生成 getStaticProps(context) getStaticPaths(context) 服务器渲染 getServerSideProps(context) 客户端获取数据 SWR（官方推荐） 注意：在开发环境中getStaticProps和getStaticPaths每次请求都会被调用 使用，在页面文件中导出 function Page({ data }) { // Render data... } // This gets called on every request export async function getServerSideProps() { // Fetch data from external API const res = await fetch(`https://.../data`) const data = await res.json() // Pass data to the page via props return { props: { data } } } export default Page 项目结构封装axios在每次请求时显示spin组件这里要注意一点，由于服务端不存在document，所以要判断一下当前所处的环境再去执行操作。 import axios from &#39;axios&#39;; import ReactDOM from &#39;react-dom&#39;; import Spin from &#39;../components/Spin/Spin&#39;; const Axios = axios.create({ timeout: 20000 }); const csr = process.browser; // 当前正在请求的数量 let requestCount = 0; function showLoading() { if (requestCount === 0) { var dom = document.createElement(&#39;div&#39;); dom.setAttribute(&#39;id&#39;, &#39;loading&#39;); document.body.appendChild(dom); ReactDOM.render(&lt;Spin /&gt;, dom); } requestCount++; console.log(&#39;showLoading&#39;, requestCount); } function hideLoading() { requestCount--; if (requestCount === 0) { document.body.removeChild(document.getElementById(&#39;loading&#39;)); } console.log(&#39;hideLoading&#39;, requestCount); } Axios.interceptors.request.use( (config) =&gt; { csr &amp;&amp; showLoading(); return config; }, (err) =&gt; { csr &amp;&amp; hideLoading(); return Promise.reject(err); } ); Axios.interceptors.response.use( (res) =&gt; { csr &amp;&amp; hideLoading(); return res; }, (err) =&gt; { csr &amp;&amp; hideLoading(); return Promise.reject(err); } ); export default Axios; 自定义input hook使用后可以免去给每个表单组件设置onChange import { useState } from &#39;react&#39;; // 自定义input hook // 参考资料：https://rangle.io/blog/simplifying-controlled-inputs-with-hooks/ export function useInput(initialValue) { const [value, setValue] = useState(initialValue); return { value, setValue, reset: () =&gt; setValue(&#39;&#39;), bind: { value, onChange: (e) =&gt; { setValue(e.target.value); } } }; } 使用： // 没使用前 const [phone, setPhone] = useState(&#39;&#39;); &lt;input name=&quot;phone&quot; type=&quot;number&quot; placeholder=&quot;请输入您的手机号码(必填)&quot; className={`${styles[&#39;cell-content&#39;]} ${styles[&#39;cell-content-right&#39;]}`} value={phone} onChange={() =&gt; setPhone(e.target.value)} /&gt; // 使用后 const { value: phone, bind: bindPhone } = useInput(&#39;&#39;); &lt;input name=&quot;phone&quot; type=&quot;number&quot; placeholder=&quot;请输入您的手机号码(必填)&quot; className={`${styles[&#39;cell-content&#39;]} ${styles[&#39;cell-content-right&#39;]}`} {...bindPhone} /&gt; 封装Dialogimport { createPortal } from &#39;react-dom&#39;; import styles from &#39;./Modal.module.css&#39;; export default function Modal({ content, show, onOk }) { const modal = show &amp;&amp; ( &lt;div className={styles[&#39;overlay&#39;]}&gt; &lt;div className={styles[&#39;modal&#39;]}&gt; {/* 防止冒泡关闭窗口 */} &lt;div className={styles[&#39;wrapper&#39;]} onClick={(e) =&gt; e.stopPropagation()}&gt; &lt;div className={styles[&#39;content&#39;]}&gt;{content}&lt;/div&gt; &lt;div className={styles[&#39;readed_btn&#39;]} onClick={() =&gt; onOk()}&gt; 好 的 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); const ProtalContent = () =&gt; { // 用来处理服务端不存在document的问题 try { // 将modal挂在到body上 return document &amp;&amp; createPortal(modal, document.body); } catch (error) { return null; } }; // 动态引入组件 // import dynamic from &#39;next/dynamic&#39;; // const Modal = dynamic(() =&gt; import(&#39;./components/Modal/Modal&#39;), { ssr: false }); return ( &lt;&gt; &lt;ProtalContent /&gt; &lt;/&gt; ); } 移动端适配使用插件postcss-px-to-viewport 在根目录下新建文件postcss.config.js module.exports = { plugins: { &#39;postcss-px-to-viewport&#39;: { // 视窗的宽度，对应的是我们设计稿的宽度，我们公司用的是375 viewportWidth: 375, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 // viewportHeight: 1334, // 指定`px`转换为视窗单位值的小数位数 unitPrecision: 3, // 指定需要转换成的视窗单位，建议使用vw viewportUnit: &#39;vw&#39;, // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 selectorBlackList: [&#39;.ignore&#39;], // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值 minPixelValue: 1, // 允许在媒体查询中转换`px` mediaQuery: false // exclude: undefined } } }; 使用Docker+coding实现自动化部署dockerfile # node版本号 FROM node:12-alpine # docker build时传进来的值 docker image build -t &lt;name&gt; --build-arg API_ENV=development . ARG API_ENV RUN echo ${API_ENV} ENV NEXT_PUBLIC_API_ENV=${API_ENV} # Create app directory RUN mkdir -p /usr/src/app WORKDIR /usr/src/app # Install app dependencies COPY package*.json /usr/src/app/ RUN npm install # Bundle app source COPY . /usr/src/app RUN npm run build EXPOSE 3000 CMD [ &quot;npm&quot;, &quot;run&quot;, &quot;start&quot; ] 在coding上设置代码push触发规则，触发生成制品库。 使用redux https://github.com/vercel/next.js/tree/canary/examples/with-redux https://github.com/vercel/next.js/tree/canary/examples/with-redux-thunk Next.js 踩坑环境变量环境变量在客户端无法获取，背景：由于我在项目中需要根据环境变量来使用不同环境的API域名。 解决方案：官方提供了以NEXT_PUBLIC_开头的环境变量名，这样就可以在客户端和服务端都访问得到环境变量了。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"},{"name":"Next.js","slug":"Next-js","permalink":"https://alanwang.site/tags/Next-js/"}]},{"title":"React入门学习总结","slug":"React入门学习总结","date":"2020-11-04T10:13:56.000Z","updated":"2020-11-04T10:13:56.000Z","comments":true,"path":"posts/c05e5480/","link":"","permalink":"https://alanwang.site/posts/c05e5480/","excerpt":"总结学习React以及相关插件时遇到的难点以及重点","text":"总结学习React以及相关插件时遇到的难点以及重点 基础知识点 单向数据流（子组件不能修改父组件数据） 组件名首字母大写 可以使用&lt;React.Fragment&gt;&lt;/ React.Fragment&gt;和&lt;&gt;&lt;/&gt;包裹标签 关键字 class-&gt;className &lt;label for=&quot;id名&quot;&gt;&lt;/lable&gt;-&gt;&lt;label htmlFor=&quot;id名&quot;&gt;&lt;/lable&gt;用来扩大点击范围 不要直接修改state要使用this.setState() this指向问题 // 在constructor使用bind，无法传参数 this.handlerClick = this.handlerClick.bind(this); // 调用时使用bind，对性能优化不友好,因为每次render()时都要重新bind onChange={this.handlerClick.bind(this,num)}// 使用箭头函数 onChange={e =&gt; this.handlerClick(num)}// 声明为箭头函数,无法传参 handlerClick = (num) =&gt; { }; 循环渲染加key，不要使用index作为key值。 注释写法{/**/} dangerouslySetInnerHTML={{__html: item(需要展示的数据)}} // 不转义html标签 setState()第二个参数为回调函数 一旦state、props变化，render()就会执行。也就是说一旦父组件state变化时，render()会执行所以其父组件的中的子组件也会再render()一遍。 动画组件react-transition-group 当组件中只有render()时，可以把它声明成一个无状态组件，可以提升性能 ref用来获取dom元素，ref={(element) =&gt; {}}element为该元素 组件通信父-&gt;子通过属性传递，子组件通过this.props接受，父组件值的改变会直接影响到子组件。 父组件 // 父组件中使用子组件 const name = &#39;Alan&#39; &lt;Child name={name} /&gt; 子组件 &lt;div&gt;{this.props.name}&lt;/div&gt; 子-&gt;父亲父组件将自己方法传递给子组件，子组件通过添加事件来调用该方法。这样就可以达到子组件修改父组件数据的目的，同时可以将子组件的数据传递给父组件。 父组件 this.state = { list: [1,2,3] } &lt;Child handlerEvent={this.deleteItem.bind(this)} /&gt; // 方法 deleteItem(index) { const list = [...this.state.list]; list.splice(index,1); this.setState({ list, }); } 子组件 &lt;button onClick = {() =&gt; this.props.handlerEvent(1)}&gt;&lt;/button&gt; props参数校验及默认值具体参数 import PropTypes from &#39;prop-types&#39;; // 参数校验 // Child为组件名 // 定义this.props.content为string类型并且为必须参数 Child.propTypes = { content: PropTypes.string.isRequired, }; // 参数默认值 Child.defaultProps = { mobile: &#39;none&#39;, }; 异步组件加载插件react-loadable使用方式 import React, { Component } from &#39;react&#39;; import Loadable from &#39;react-loadable&#39;; const LoadableComponent = Loadable({ // 需要异步引入的组件 loader: () =&gt; import(&#39;./index&#39;), loading() { // 加载时进行的操作，这里显示loading提升用户体验 return &lt;div&gt;loading...&lt;/div&gt;; }, }); export default class App extends Component { render() { return &lt;LoadableComponent /&gt;; } } 虚拟DOM何为虚拟DOM 使用JS对象来描述真实DOM，虚拟DOM（JS对象）的操作性能要远远优于真实DOM操作性能。 通过React.createElement(type, [props], [...children])来生成虚拟DOM 优点： DOM操作很耗性能，虚拟DOM操作性能好 无需替换全部DOM，通过diff算法比对替换局部改变的DOM 由于使用了虚拟DOM，有利于原生应用的开发（RN），因为DOM是存在于浏览器中的。 出于性能考虑，react将多次setState(异步函数)合并成一次setState，因为setState会导致虚拟DOM进行diff对比。 同层比对 diff算法 生命周期 mounting componentWillMount()/UNSAFE_componentWillMount() render() componentDidMount()应用场景：发送请求 updation(props/state发生变化) componentWillReceiveProps()将废除 shouldComponentUpdate(): boolean更新之前，返回true时才会更新 render() componentDidUpdate() unmounting componentWillUnmount() 性能优化 // 只有当子组件数据变化时才去执行render() shouldComponentUpdate(nextProps, nextState) { return nextProps.content !== this.props.content; // 防止更新影响性能 } 也可以使用组件去继承React.PureComponent以达到和上面一样的效果，但是应该减少使用，因为它存在一些问题。问题 在hook中也有类似的API：useMemo和useCallback useMemo参考资料： How to useMemo in React 可以使用Charles实现接口mock。localhost-&gt;本地文件.json Redux 思路： 组件通过dispatch(action)来通知store，store根据action来调用对应的reducers来操作store副本，reducers将处理好的数据返回给store。 store和组件之间通过，store.subscribe(this.setState(store.getState()))来同步最新的store数据。 创建store(createStore()) import { createStore } from &quot;redux&quot;; import reducer from &quot;./reducer&quot;; // 第二个参数配置后可以使用谷歌redux插件 const store = createStore( reducer, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__() ); export default store; 创建reducer（管理操作数据store副本） const defaultState = { todoText: &#39;&#39; }; export default (state = defaultState, action) =&gt; { if (action.type === &#39;action的type&#39;) { let newState = JSON.parse(JSON.stringify(state)); // 更新store newState.todoText = action.value; return newState; } return state; } 可以通过store.getState()来获取store中的数据，给组件赋初值 this.state = store.getState(); 创建action const action = { type: &#39;&#39;, value: &#39;&#39; // 要改变的值 } 通过store.dispatch(action)通知store，reducer将接收到修改之前的state和action reducer更新state的副本，将新state返回给store 使用store的组件中通过store.subscribe(this.setState(store.getState()))订阅store来同步最新的store 为了提高代码健壮性和可维护性，把action单独声明为一个文件，并且把action.type声明为一个常量文件。 store ├── actionCreators.js // 生成action ├── actionType.js // action type对应的常量 ├── index.js └── reducer.jsindex.jsactionCreators.jsreducer.jsactionType.jsimport { createStore } from 'redux'; import reducer from './reducer'; const store = createStore( reducer, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__() ); export default store;import { INPUT_CHANGE } from './actionType'; export const changeInputAction = (value) =&gt; ({ type: INPUT_CHANGE, value, });import { INPUT_CHANGE } from './actionType'; const defaultState = { todoText: '', }; export default (state = defaultState, action) =&gt; { if (action.type === INPUT_CHANGE) { let newState = JSON.parse(JSON.stringify(state)); newState.todoText = action.value; return newState; } return state; }export const INPUT_CHANGE = 'inputChange'; reducers函数的返回值要是可预测，也就是说里面不能写类似new Date,Ajax等的不可预测结果的代码 reducers不能修改原来的state，只能返回一个新的state，为了防止被误改造成bug，可以使用immutable.js来解决，它可以将state数据转化成一个特定的对象 npm i immutable redux-immutable -S immutable对象通过get()和set()等api来操作数据，当有多个set()连用时可以使用merge({})来实现 immutable通过fromJS可以将state转化成immutable对象，通过toJS()将immutable对象转化成js对象 redux-immutable也提供了combineReducers，结合不同模块的reducers的同时还可以将state转化成immutable对象。 当项目越来越大时，项目中的reducer.js文件也会越来越臃肿，这个时候我们可以通过redux提供的combineReducers来将reducer拆分成不同的模块。 import { combineReducers } from &#39;redux&#39;; import mAReducer from &#39;../mAReducer/store/reducer&#39;; import mBReducer from &#39;../mBReducer/store/reducer&#39;; export default combineReducers({ A: mAReducer, B: mBReducer, }); // 这样我们在使用mAReducer中的数据是就要通过state.A.xxx来获取其数据了 redux-thunk中间件：位于action和store之间 redux-thunk可以让redux使用异步操作 使用方式 import { createStore, applyMiddleware, compose } from &#39;redux&#39;; import reducer from &#39;./reducer&#39;; import thunk from &#39;redux-thunk&#39;; const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; const enhancer = composeEnhancers(applyMiddleware(thunk)); const store = createStore(reducer, enhancer); export default store; 例子 actionCreators.js组件使用export const setTodoList = (list) =&gt; ({ type: GET_TODOLIST, list, }); export const getTodoList = () =&gt; { return (dispatch) =&gt; { axios.get('http://localhost:8888/test/getTodoList') .then((res) =&gt; { const todoList = res.data.datas; const action = setTodoList(todoList); dispatch(action); }); } };componentDidMount() { const action = getTodoList(); store.dispatch(action); } redux-saga使用方式 index.jsactionCreators.jssagas.jsimport { createStore, applyMiddleware, compose } from 'redux'; import reducer from './reducer'; import createSagaMiddleware from 'redux-saga'; import mySaga from './sagas'; const sagaMiddleware = createSagaMiddleware(); const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({}) : compose; const enhancer = composeEnhancers(applyMiddleware(sagaMiddleware)); const store = createStore(reducer, enhancer); sagaMiddleware.run(mySaga); export default store;export const getSaga = (list) =&gt; ({ type: GET_SAGA, list, });import { takeEvery } from 'redux-saga/effects'; import { GET_SAGA } from './actionType'; function* getList() { console.log('进行异步操作了'); } function* mySaga(action) { // 当dispatch的action.type = GET_SAGA时，调用getList方法 yield takeEvery(GET_SAGA, getList); } export default mySaga; react-redux使用Provider和connect实现store的共享，之前的写法是需要在需要使用store的组件中引入store，并通过store.subscribe和store.getState来同步和获取最新的store内容。 &lt;Provider store={store}&gt; {/* 包裹需要使用store的组件 */} &lt;App /&gt; &lt;/Provider&gt; Demo.js import { deleteTodoItemAction } from &#39;../../store/actionCreators&#39;; // 将store中的state的数据映射到组件的props中 const mapStateToProps = (state) =&gt; ({ ...state, }); // 将dispatch映射到props中 const mapDispatchToProps = (dispatch) =&gt; { return { deleteTodoItem(index) { const action = deleteTodoItemAction(index); dispatch(action); } }; }; // Demo为需要使用store的组件 connect(mapStateToProps, mapDispatchToProps)(Demo); hook如果使用的是hook进行开发的话，可以使用react-redux提供的hookapi来简化书写,并且不需要使用connect()来包裹组件，但是仍然需要使用Provider包裹父组件 import { useSelector, useDispatch } from &#39;react-redux&#39; import { deleteTodoItemAction } from &#39;../../store/actionCreators&#39;; // 等同于前面的mapStateToProps const counter = useSelector(state =&gt; state.counter) const dispatch = useDispatch() // 使用 dispatch(deleteTodoItemAction) useSelector：返回state中的值，当一个action被dispatch时，useSelector会把之前的selector返回的结果和现在的结果进行浅比较（默认深比较===），如果不相同的话组件会被强制渲染，否则不会。 css写法react不像vue那样可以优雅的在vue文件中写css代码，不过react也提供了几种css书写方式（待补充） css in js 使用styled-components css-module（依赖于webpack） styled-components(使用js编写css代码) style.js使用方式import styled from 'styled-components'; export const Logo = styled.a.attrs({ href: '/', })` position: absolute; top: 0; left: 0; background: url(${(props) =&gt; props.imgUrl}); `;import React, { Component } from 'react'; import { Logo } from './style'; class Header extends Component { constructor(props) { super(props); this.state = {}; } render() { return ( &lt;Logo imgUrl=\"xxx\"/&gt; ); } } export default Header; 上面这种写法等同于 render() { return ( &lt;a href=&quot;/&quot; style={{position: \"absolute\", top: 0, left: 0}}&gt;&lt;/a&gt; ); } react-routernpm i react-router-dom -S使用方式 import React from &#39;react&#39;; import Header from &#39;./common/header&#39;; import store from &#39;./store&#39;; import { BrowserRouter as Router, Route } from &#39;react-router-dom&#39;; import { Provider } from &#39;react-redux&#39;; import Home from &#39;./pages/home&#39;; import Detail from &#39;./pages/detail&#39;; function App() { return ( &lt;Provider store={store}&gt; &lt;Router&gt; &lt;Header /&gt; &lt;Route path=&quot;/&quot; exact component={Home}&gt;&lt;/Route&gt; &lt;Route path=&quot;/detail&quot; exact component={Detail}&gt;&lt;/Route&gt; &lt;/Router&gt; &lt;/Provider&gt; ); } export default App; exact为精准匹配路由 页面跳转，使用react-router-dom中的&lt;Link to=&quot;xxx&quot;&gt;&lt;/Link&gt;，重定向使用&lt;Redirect to=&quot;xxx&quot;&gt;&lt;/Redirect&gt; 编程式写法： this.props.history.(push()/goBack(num)/go()/replace()) 动态路由 &lt;Route path=&quot;/post/:id&quot; exact component={POST}&gt;&lt;/Route&gt; // POST组件通过this.props.match.params.id来获取id值 可以使用withRouter包裹组件来获取history 总结React对比Vue来说，学习成本比较高，但是比较灵活。而vue提供了很多封装好的api，学习起来对小白比较友好。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"}]},{"title":"TypeScript学习总结（一）","slug":"TypeScript学习总结（一）","date":"2020-07-01T03:52:09.000Z","updated":"2020-07-01T03:52:09.000Z","comments":true,"path":"posts/fc7889ef/","link":"","permalink":"https://alanwang.site/posts/fc7889ef/","excerpt":"TypeScript常用知识点总结","text":"TypeScript常用知识点总结 什么是TypeScriptTypeScript是JavaScript的一个超集，在JavaScript的基础上增加了可选的静态类型和基于类的面向对象编程。它可以编译成纯JavaScript，未编译的ts代码无法在浏览器执行。我们可以把它和JavaScript的关系理解成css和less、sass的关系。 TypeScript好在哪里 TS可以进行动态类型检测，可以检测出一些潜在的bug（例如拼写错误、参数缺失、undefined等），提升代码健壮性 使用vscode进行开发可以很好的提示代码，提高开发效率 代码可读性好 创建第一个TypeScript文件首先安装TypeScript npm install -g typescript安装后看是否成功 tsc --version我安装后出现了以下问题：这种情况只需要以管理员的身份打开命令行运行以下命令： set-ExecutionPolicy RemoteSigned创建第一个ts文件Hello.ts function sayHello(name:String) { console.log(`Hello ${name}`); } let person = &quot;Alan&quot;; sayHello(person); 我们发现ts代码和普通的js代码在sayHello函数的参数上有所不同。sayHello(name: String)大致的意思就是sayHello传入一个名为name的参数，该参数的类型必须是String，不然无法通过ts的编译。代码写好后用tsc编译上面的Hello.ts文件 tsc Hello.ts编译成功后在同级目录下生成一个Hello.js文件，可以看到生成的js文件只是将es6语法转化成了es5语法，并没有改变其他代码。 function sayHello(name) { console.log(&quot;Hello &quot; + name); } var person = &quot;Alan&quot;; sayHello(person); 如果把Hello.ts文件改写一下 function sayHello(name:String) { const text = 3 + name; console.log(`Hello ${name}`); } let person = 123; sayHello(person); 再次编译发现会报错但是仍然能生成js文件： 上面错误的具体意思是 由于声明了函数形参name为静态类型string，而在调用时传入得是number类型123，与前面的string不符。 在sayHello函数中将name(string)和3(number)两种不同类型得值进行了相加。 我们发现每次都要通过tsc来编译ts文件能得到js文件后再去运行js文件，过于麻烦。可以使用插件ts-node来直接运行ts文件。 npm i ts-node -gts-node Hello.ts ts能够尝试分析变量类型（类型推断），ts无法分析出的变量最好显式声明变量类型（类型注解） 基础类型变量的声明：let [变量名] : [类型] = 值 例如： let age: number = 21 TypeScript支持与JavaScript几乎相同的数据类型 boolean(布尔值) number(数值) string(字符串) []/Array&lt;元素类型&gt;(数组) 元组Tuple enum(枚举) any(任何值) void(空值) null undefined never 数组有2种方式定义数组 let arr : number[] = [1,2,3] // 元素类型后接上`[]` let arr : Array&lt;number&gt; = [1,2,3] // 数组泛型 let arr: (number | string)[] = [1, &#39;2&#39;, &#39;4&#39;] // 元素类型可以是number或string（类似元组） 元组tuple表示一个数组（各个元素的类型不必相同） let list : [string, number]; //第一个元素为string类型，第二个为number类型 a = [&#39;abc&#39;, 123] //合格 b = [123, &#39;abc&#39;] //不合格 枚举其实有点类似对象看例子吧 enum lan {js, ts, css}; console.log(lan.js); // 0 js对应的下标，第一个默认下标为0 enum lan { js = 3, ts, css, } console.log(lan.js); // 3 console.log(lan.ts); // 4 console.log(lan.css); // 5 enum lan { js, ts = 3, css, } console.log(lan.js); // 0 console.log(lan.ts); // 3 console.log(lan.css); // 4 console.log(lan[4]); // css console.log(lan[1]); // undefined // 第一个默认下标为0，css接着ts的值+1 enum lan {js = &#39;good&#39;, ts = &#39;nice&#39;, css = &#39;well&#39;}; console.log(lan.js); // good any顾名思义，任意值，当我们想为还不清楚类型的变量指定一个类型时，any就是最好的选择🤭 let a:any =4; a = &#39;123&#39;; //合格 let arr : any[] = [1, &#39;123&#39;, true]; // 和元组很像 arr[1] = &#39;good&#39;; void常用于无返回值的函数声明 function func() : void { console.log(&#39;learning typescript...&#39;); } func(); //合格 function func() : void { return 1; } func(); // 不合格：Type &#39;1&#39; is not assignable to type &#39;void&#39; null和undefined用处不大，默认情况下是所有类型的子类型，例如下面代码是没有问题的： let a:string; a = undefined; a = null; 但是，当指定--strictNullChecks标记时，null和undefined只能赋值给void和他们自己本身。 never表示永不存在的值的类型never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；变量也可能是never类型，当它们被永不为真的类型保护所约束时。 never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使any也不可以赋值给never。 function error(message:string) : never{ throw new Error(message); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } 结构赋值的写法function sayAge({name, age}: {name: string | number, age: number}): void { console.log(`${name} is ${age} years old`); } sayAge({name: &#39;Alan&#39;, age: 22}) sayAge({name: 2, age: 22}) 联合类型用|来表示取值存在多种可能 let a: string | number; a = 1; a = &#39;A&#39;; 类型断言可以自己指定一个值的类型格式如下&lt;类型&gt;值值 as 类型 interface student { isStudent: boolean; education: number; } interface worker { isStudent: boolean; seniority: number; } function Recruit(candidate: worker | student): void { if (candidate.isStudent) { console.log(`your education is ${(candidate as student).education}`); } else { console.log(`your seniority is ${(candidate as worker).seniority}`); } } const a: student = { isStudent: true, education: 4 }; const b: worker = { isStudent: false, seniority: 2 }; Recruit(a); Recruit(b); 由于candidate使用了联合类型，所以ts无法判断candidate究竟是属于student还是worker，所以要使用类型断言来显式告诉ts。 当然还有其他方式来实现 interface student { isStudent: boolean; education: number; } interface worker { isStudent: boolean; seniority: number; } function Recruit(candidate: worker | student): void { &#39;education&#39; in candidate &amp;&amp; console.log(`your education is ${candidate.education}`); &#39;seniority&#39; in candidate &amp;&amp; console.log(`your seniority is ${candidate.seniority}`); } const a: student = { isStudent: true, education: 4 }; const b: worker = { isStudent: false, seniority: 2 }; Recruit(a); Recruit(b); typeof instanceof 接口interface先看一个接口的例子 interface person { name: string; } function work(personObj:person) { console.log(personObj.name); } let person1 = {name: &#39;Alan&#39;, age: 21}; work(person1); let person2 = {age: 21}; work(person2); 定义接口的关键字是interface这个例子需要传入work的参数必须是一个带有name(string)的对象，可以理解为我要招聘一个有名字的员工，没有名字的都不需要。当然我们的person1中还多了一个age属性，这并不会报错。可是当我们直接传递参数时是会出错的。 work({name: &#39;Alan&#39;, age: 21}); 那如果我不确定要招聘的员工除了有姓名外还需要其他什么属性时，可以像下面一样重新定义接口就可以解决上面的问题了。 interface person { name: string; [propName: string]: any } 可选属性那如果我的招聘条件是最好懂typescript的，这个时候typescript就是可有可无的（最好懂，嘿嘿😜），那我们就要用到可选属性了可选属性在可选属性名后面加上一个? interface person { name: string; ts?: boolean; } function Recruit(personObj:person) : string{ if(personObj.ts) { return `congratulations!${personObj.name}`; } else { return `sorry,${personObj.name}, we need a employee who know ts!`; } } let person1 = {name: &#39;Alan&#39;, age: 21, ts: true}; console.log(Recruit(person1)); let person2 = {name: &#39;Bob&#39;, age: 21}; console.log(Recruit(person2)); 只读属性我们都知道人的名字都是不可以改变的（一般情况下），这个时候我们对person接口里面的name属性稍作修改，在属性名name前加上readonly。 当然也可以使用setter/getter来实现 interface person { readonly name: string; ts?: boolean; } let person1: person = {name: &#39;Alan&#39;}; person1.name = &#39;Bob&#39;; // Cannot assign to &#39;name&#39; because it is a read-only property. 我们发现readonly和const的作用好像有点相似，那我们什么时候使用readonly什么时候使用const呢？变量—-&gt;const属性—-&gt;readonly 函数类型的接口接口除了可以描述带有属性的对象外，还可以描述函数类型这里创建一个函数来检查你有没有打卡😁 interface attendanceFunc { (name:string, startTime: number, endTime: number) : boolean; } let checkAttendance : attendanceFunc; checkAttendance = function (name:string, startTime: number, endTime: number) : boolean { let result = startTime &lt; 9 &amp;&amp; endTime &gt;18; return result; } console.log(checkAttendance(&#39;Alan&#39;, 10, 19)); // false 看一下接口的声明： interface attendanceFunc { (name:string, startTime: number, endTime: number) : boolean; } name,startTime,endTime放在()中代表函数的参数:boolean表示函数的返回值类型当然上面例子中的checkAttendance的形参以及函数的返回值来说可以不指定类型，因为checkAttendance复制给了attendanceFunc变量，类型检查器会自动(按照接口中参数的顺序)推断出参数以及返回值的类型，也就是说写成下面这样也是可以的。函数中的参数名可以不和接口中的相同 interface attendanceFunc { (name:string, startTime: number, endTime: number) : boolean; } let checkAttendance : attendanceFunc; checkAttendance = function (n, startTime, endTime) { let result = startTime &lt; 9 &amp;&amp; endTime &gt;18; return result; } console.log(checkAttendance(&#39;Alan&#39;, 10, 19)); // false 接口的继承一个接口可以继承1个或者多个接口：继承使用关键词extends interface person { name : string; } interface student { studentId : number; } interface seniorStudent extends person, student { grade: string; } let student1 : seniorStudent = {name: &#39;Alan&#39;, studentId: 1, grade: &#39;one&#39;}; console.log(student1); 类classTS中的类和ES6中的类很相似，这里只介绍不同的地方 变量修饰符 public（默认） private（私有，不能在声明它的类的外部访问） protected（和private类似，不同的是protected声明的变量可以在派生类（即子类）中访问） 静态属性staticclass Person { static fingerNum = 5; } // 只能通过类来访问 console.log(Person.fingerNum); // 不能通过实例访问 console.log(new Person().fingerNum); // 单例模式创建唯一的实例 class singleClass { private static instance: singleClass; private constructor(public name: string) {} static getInstance() { if (!this.instance) { this.instance = new singleClass(&#39;Alan&#39;); } return this.instance; } } const class1 = singleClass.getInstance(); const class2 = singleClass.getInstance(); console.log(class1.name); // Alan console.log(class1 === class2); // true 构造函数class Person { constructor(name, mobile, sex) { this.name = name; this.mobile = mobile; this.sex = sex; } public name: string; private mobile: string; protected sex: string; } 上面的代码可以简写成下面这样 class Person { constructor(name: string, private mobile: string, protected sex: string) { } } 抽象类 不能被实例化 要使用的话要声明其派生类，并且重写其中的抽象方法 abstract class Animal { constructor(public name: string) {} sayHello() { console.log(&#39;hello&#39;); } // 声明抽象方法 abstract action(): void; } class Bird extends Animal{ constructor(name) { super(name); } action() { console.log(&#39;jijiji&#39;); } } const bird = new Bird(&#39;qc&#39;); console.log(bird); // Bird { name: &#39;qc&#39; } 泛型 泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 用法：&lt;泛型名&gt; function Recruit&lt;T&gt;(name: string, props: T) { return name + props; } // 显式指定为T为number类型 console.log(Recruit&lt;number&gt;(&#39;Alan&#39;, 123)); // Alan123 // TS自动推断为number类型，和上面效果一样 console.log(Recruit(&#39;Alan&#39;, 123)); // Alan123 console.log(Recruit(&#39;Alan&#39;, [1, 2, 3])); // Alan1,2,3 泛型约束试用extends约束泛型 interface info { mobile: string; } // T泛型必须满足info function Recruit&lt;T extends info&gt;(name: string, props: T) { return name + props.mobile; } console.log(Recruit(&#39;Alan&#39;, { mobile: &#39;1232910830&#39; })); // Alan1232910830","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"TypeScript","slug":"前端/TypeScript","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://alanwang.site/tags/TypeScript/"}]},{"title":"Hexo博客定制","slug":"Hexo博客定制","date":"2020-06-13T05:51:44.000Z","updated":"2020-06-13T05:51:44.000Z","comments":true,"path":"posts/b050203a/","link":"","permalink":"https://alanwang.site/posts/b050203a/","excerpt":"介绍了评论系统以及一些自定义配置","text":"介绍了评论系统以及一些自定义配置 评论系统注册一个LeanCloud国际版账号（国内的好像需要绑定域名和备案）注册地址👉https://console.leancloud.app/login.html#/signup 之后创建一个应用，名字随便取 在设置中找到应用keys,把appid和appkey复制到hexo对应的配置当中。由于本文重点讲邮件回复功能，这一部分就不多过赘述了😝。直接进入正题。 修改邮件模板 &lt;p&gt;Hi, {{username}}&lt;/p&gt; &lt;p&gt; 你在 {{appname}} 的评论收到了新的回复，请点击查看： &lt;/p&gt; &lt;p&gt;&lt;a href=&quot;https://alanwang.site&quot; style=&quot;display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;&quot;&gt;马上查看&lt;/a&gt;&lt;/p&gt; 部署valine-admin首先进行配置 更多配置参考：https://github.com/DesertsP/Valine-Admin https://github.com/DesertsP/Valine-Admin.git网上的zhaojun1998版本我之前也试过，但是在国际版部署是会报错的，看错误信息应该是node版本太低了，而且就算部署成功了，后台也是登录不了的。这个版本我实测是没有问题的。 部署分支默认为master 点击部署即可 点击该链接访问后台管理系统（这里需要用户名和密码登录，需要到存储中的_User中自行创建） 这里只需要填写username、password、email即可，添加后在后台管理系统输入邮箱和密码就可以成功登录了。 设置定时唤醒 0 */30 7-23 * * ? 添加百度统计完成以下操作 注册百度统计账号 复制统计代码 将代码粘贴到G:\\blog\\themes\\volantis\\layout\\_partial下的footer.ejs 配置G:\\blog\\_config.yml baidu_analytics_key: 上面图片中的key值 查看是否配置成功 直接使用官网的代码检查就可以，如果没有用可以使用下面这种方法。 在控制台network中查看自己的网站是否有hm开头的请求，有就代表了成功了，大概20分钟后就可以在百度统计中看到数据了。 使用hexo-admin管理安装hexo-admin npm i hexo-admin -S运行命令 hexo s -d通过localhost:4000/admin访问即可如需使用hexo-admin中的deploy，只需在_config.yml中配置 admin: deployCommand: &#39;./hexo-deploy.sh&#39; hexo-abbrlink生成永久链没修改前的链接是这样的 我们一旦修改了文章的发布日期， 那么这个链接就会失效了。 那我们通过hexo-abbrlink处理一下 首先安装 npm i hexo-abbrlink -S 修改_config.yml下的配置 permalink: posts/:abbrlink/ abbrlink: alg: crc32 rep: hex 详细配置可以查看官网 本博客待优化： 优化seo，收录到百度和谷歌搜索 样式微调 去除消耗加载速度的插件 使用cdn","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://alanwang.site/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://alanwang.site/tags/Hexo/"},{"name":"Valine国际版","slug":"Valine国际版","permalink":"https://alanwang.site/tags/Valine%E5%9B%BD%E9%99%85%E7%89%88/"},{"name":"Hexo评论系统","slug":"Hexo评论系统","permalink":"https://alanwang.site/tags/Hexo%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"name":"DIY博客","slug":"DIY博客","permalink":"https://alanwang.site/tags/DIY%E5%8D%9A%E5%AE%A2/"}]},{"title":"webpack4.0进阶（三）","slug":"webpack4.0进阶（三）","date":"2020-06-05T02:24:19.000Z","updated":"2020-06-13T08:06:00.000Z","comments":true,"path":"posts/f9d92613/","link":"","permalink":"https://alanwang.site/posts/f9d92613/","excerpt":"手写简单的loader、Plugin、简单的webpack","text":"手写简单的loader、Plugin、简单的webpack 手写简单的loader目录 myLoader ├── loaders │ └── myLoader.js ├── package.json ├── src │ └── index.js └── webpack.config.jsindex.jswebpack.config.jsmyLoader.jsconsole.log('hello webpack!');const path =require('path'); module.exports = { mode: 'development', entry: './src/index.js', module: { rules: [{ test: /\\.js$/, exclude: /node_modules/, use: [ { loader: path.resolve(__dirname, './loaders/myLoader.js'), options: { key: 'my option value', }, }, ], }], }, output: { path: path.resolve(__dirname, 'dist'), filename: '[name].js', }, };module.exports = function (source) { return source.replace('webpack', this.query.key); } 这个例子非常简单，就是通过自建的loader将项目中的webpack字符串替换成webpack中配置的字符串。myLoader.js中可以通过this.query接受webpack中配置的options参数。更多this上的属性参考（包括异步处理、回调…） 上面的例子通过打包后代码如下 console.log(&#39;hello my option value!&#39;) webpack5中可以直接通过this.getOptions (schema)来获取options参数 webpack resolveLoader: 和之前提到的resolve的使用类似，就是用来偷懒的😂 使用resolveLoader改写后的wepack.config.js const path =require(&#39;path&#39;); module.exports = { mode: &#39;development&#39;, entry: &#39;./src/index.js&#39;, resolveLoader: { modules: [&#39;node_modules&#39;, &#39;./loaders&#39;], }, module: { rules: [{ test: /\\.js$/, exclude: /node_modules/, use: [ { loader: &#39;myLoader&#39;, options: { key: &#39;my option&#39;, }, }, ], }], }, output: { path: path.resolve(__dirname, &#39;dist&#39;), filename: &#39;[name].js&#39;, }, }; 上面这个例子可以直接使用myLoader名，webpack会在node_modules 和./loaders中寻找对应的Loader。 自定义的loader中不要使用箭头函数，会产生this指向问题 手写简单的Plugin目录 myPlugin ├── package.json ├── plugins │ └── date-webpack-plugin.js ├── src │ └── index.js └── webpack.config.jscomplier提供了许多钩子，可以让我们在打包的不同时刻来进行不同的处理，这里使用了emit钩子 下面通过手写的plugin来实现在dist目录下生成一个author.txt文件 date-webpack-plugin.jswebpack.config.jsclass DateWebpackPlugin { constructor(options) { // options是new插件时传进来的参数 this.options = options; } apply(compiler) { const _this = this; compiler.hooks.emit.tapAsync('DateWebpackPlugin', (compilation, cb) =&gt; { compilation.assets['author.txt'] = { // 返回的资源 source: function () { return `created by ${_this.options.author} ${new Date()}`; }, // 最后生成的文件大小 size: function () { return 19; } }; // 由于emit是异步操作，所以最后要执行回调函数 cb(); }) } } module.exports = DateWebpackPlugin;const path = require('path'); const DateWebpackPlugin = require('./plugins/date-webpack-plugin'); module.exports = { mode: 'development', entry: './src/index.js', output: { path: path.resolve(__dirname, 'dist'), filename: '[name].js', }, plugins: [ new DateWebpackPlugin({ author: 'Alan', }), ], }; 打包后会在dist目录下自动生成一个author.txt文件，内容如下 created by AlanSun Jun 07 2020 11:49:42 GMT+0800 (GMT+08:00)react和vue脚手架webpack配置 create-react-app通过npm run eject暴露webpack配置 vue-cli通过vue.config.js配置webpack(可以通过configureWebpack自定义webpack配置) 手写一个简单的webpack打包工具先提前安装以下需要的插件 npm i @babel/parser -D // 将js内容转化为抽象语法树 npm i @babel/traverse -D // 用来遍历抽象语法树 npm i @babel/core -D npm i @babel/preset-env -D //es6-&gt;es5 npm i cli-highlight -D // 可选，命令行高亮插件前置知识： node： fs.readFileSync(同步读取文件内容) path_dirname(获取文件的目录) 项目目录： bundler ├── bundler.js // 主要文件 └── src ├── course.js ├── index.js └── learn.jsindex.jslearn.jscourse.jsimport notify from './learn.js'; console.log(notify);import { course } from './course.js'; const learnNotify = `time to learn ${course}`; export default learnNotify;export const course = 'webpack'; 我将整个项目拆分成2个部分来分析 处理入口文件找到所有import文件思路： 通过fs.readFileSync读取index.js的内容 使用@babel/parser将读取的内容转化为AST抽象语法树 使用@babel/traverse遍历找到所有import语句 分析出引用的文件，保存其路径 代码： const fs = require(&#39;fs&#39;); const parser = require(&#39;@babel/parser&#39;); const traverse = require(&#39;@babel/traverse&#39;).default; // 命令行高亮工具 const highlight = require(&#39;cli-highlight&#39;).highlight const moduleAnalysis = (filename) =&gt; { // 读取出index.js文件内容 const content = fs.readFileSync(filename, &#39;utf-8&#39;); // 将文件内容转化为抽象语法树 const ast = parser.parse(content, { sourceType: &#39;module&#39; }); // 遍历抽象语法树 traverse(ast, { ImportDeclaration({ node }) { console.log(node); } }) // console.log(highlight(ast)); console.log(ast.program.body); } moduleAnalysis(&#39;./src/index.js&#39;); 通过上图可以清楚看到我们现在要做的事情就是找到所有为type为importDeclaration的node属性 最后对js文件进行babel处理，转化成浏览器能够识别的代码 完整代码 const fs = require(&#39;fs&#39;); const parser = require(&#39;@babel/parser&#39;); const traverse = require(&#39;@babel/traverse&#39;).default; const path = require(&#39;path&#39;); const babel = require(&#39;@babel/core&#39;); // 命令行高亮工具 const highlight = require(&#39;cli-highlight&#39;).highlight const moduleAnalysis = (filename) =&gt; { // 读取出index.js文件内容 const content = fs.readFileSync(filename, &#39;utf-8&#39;); // 将文件内容转化为抽象语法树 const ast = parser.parse(content, { sourceType: &#39;module&#39; }); const dependencies = {}; // 遍历抽象语法树 traverse(ast, { ImportDeclaration({ node }) { // 文件对应目录./src const dirPath = path.dirname(filename); // 绝对路径./src/learn.js(window操作系统) let filePath = (&#39;./&#39; + path.join(dirPath, node.source.value)).replace(&#39;\\\\&#39;, &#39;/&#39;); dependencies[node.source.value] = filePath; // { &#39;./learn.js&#39;: &#39;./src/learn.js&#39; } console.log(dependencies); } }); // 转化成浏览器可以执行的代码 const { code } = babel.transformFromAst(ast, null, { presets: [&#39;@babel/preset-env&#39;] }); console.log(highlight(code)); return { filename, dependencies, code } } moduleAnalysis(&#39;./src/index.js&#39;); 通过入口文件分析出所有文件依赖上面已经分析出了入口文件的一些依赖，接下来可以通过递归遍历来分析出所有的文件依赖并保存在变量中，先分析一些经过上面函数处理后的数据 { filename: &#39;./src/index.js&#39;, dependencies: { &#39;./learn.js&#39;: &#39;./src/learn.js&#39; }, code: &#39;&quot;use strict&quot;;\\n&#39; + &#39;\\n&#39; + &#39;var _learn = _interopRequireDefault(require(&quot;./learn.js&quot;));\\n&#39; + &#39;\\n&#39; + &#39;function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { &quot;default&quot;: obj }; }\\n&#39; + &#39;\\n&#39; + &#39;console.log(_learn[&quot;default&quot;]);&#39; } 我们只需要遍历对象中的dependencies属性，把里面的路径名传入到上面的moduleAnalysis函数中，最终获取所有的依赖信息。 具体代码如下 const analysisDependenciesGraph = (entry) =&gt; { const entryModule = moduleAnalysis(entry); const graphList = [entryModule]; for (let i = 0; i &lt; graphList.length; i++) { const item = graphList[i]; const { dependencies } = item; if (dependencies) { for (let i in dependencies) { graphList.push(moduleAnalysis(dependencies[i])) } } } const graph = {}; graphList.forEach(({ filename, dependencies, code }) =&gt; { graph[filename] = { dependencies, code } }); return graph; } 分析出的所有依赖对象 { &#39;./src/index.js&#39;: { dependencies: { &#39;./learn.js&#39;: &#39;./src/learn.js&#39; }, code: &#39;&quot;use strict&quot;;\\n&#39; + &#39;\\n&#39; + &#39;var _learn = _interopRequireDefault(require(&quot;./learn.js&quot;));\\n&#39; + &#39;\\n&#39; + &#39;function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { &quot;default&quot;: obj }; }\\n&#39; + &#39;\\n&#39; + &#39;console.log(_learn[&quot;default&quot;]);&#39; }, &#39;./src/learn.js&#39;: { dependencies: { &#39;./course.js&#39;: &#39;./src/course.js&#39; }, code: &#39;&quot;use strict&quot;;\\n&#39; + &#39;\\n&#39; + &#39;Object.defineProperty(exports, &quot;__esModule&quot;, {\\n&#39; + &#39; value: true\\n&#39; + &#39;});\\n&#39; + &#39;exports[&quot;default&quot;] = void 0;\\n&#39; + &#39;\\n&#39; + &#39;var _course = require(&quot;./course.js&quot;);\\n&#39; + &#39;\\n&#39; + &#39;var learnNotify = &quot;time to learn &quot;.concat(_course.course);\\n&#39; + &#39;var _default = learnNotify;\\n&#39; + &#39;exports[&quot;default&quot;] = _default;&#39; }, &#39;./src/course.js&#39;: { dependencies: {}, code: &#39;&quot;use strict&quot;;\\n&#39; + &#39;\\n&#39; + &#39;Object.defineProperty(exports, &quot;__esModule&quot;, {\\n&#39; + &#39; value: true\\n&#39; + &#39;});\\n&#39; + &#39;exports.course = void 0;\\n&#39; + &quot;var course = &#39;webpack&#39;;\\n&quot; + &#39;exports.course = course;&#39; } } 生成代码const generateCode = (entry) =&gt; { const graph = JSON.stringify(analysisDependenciesGraph(entry)); return ` (function(graph){ function require(module) { function localRequire(relativePath) { return require(graph[module].dependencies[relativePath]); } var exports = {}; (function(require, exports, code){ eval(code) })(localRequire, exports, graph[module].code); return exports; }; require(&#39;${entry}&#39;) })(${graph}); `; } 生成后的代码就可以直接在浏览器运行了 完整代码 const fs = require(&#39;fs&#39;); const parser = require(&#39;@babel/parser&#39;); const traverse = require(&#39;@babel/traverse&#39;).default; const path = require(&#39;path&#39;); const babel = require(&#39;@babel/core&#39;); // 命令行高亮工具 const highlight = require(&#39;cli-highlight&#39;).highlight const moduleAnalysis = (filename) =&gt; { // 读取出index.js文件内容 const content = fs.readFileSync(filename, &#39;utf-8&#39;); // 将文件内容转化为抽象语法树 const ast = parser.parse(content, { sourceType: &#39;module&#39; }); const dependencies = {}; // 遍历抽象语法树 traverse(ast, { ImportDeclaration({ node }) { // 文件对应目录./src const dirPath = path.dirname(filename); // 绝对路径./src/learn.js(window操作系统) let filePath = (&#39;./&#39; + path.join(dirPath, node.source.value)).replace(&#39;\\\\&#39;, &#39;/&#39;); dependencies[node.source.value] = filePath; // { &#39;./learn.js&#39;: &#39;./src/learn.js&#39; } console.log(dependencies); } }); // 转化成浏览器可以执行的代码 const { code } = babel.transformFromAst(ast, null, { presets: [&#39;@babel/preset-env&#39;] }); return { filename, dependencies, code } } const analysisDependenciesGraph = (entry) =&gt; { const entryModule = moduleAnalysis(entry); const graphList = [entryModule]; for (let i = 0; i &lt; graphList.length; i++) { const item = graphList[i]; const { dependencies } = item; if (dependencies) { for (let j in dependencies) { graphList.push(moduleAnalysis(dependencies[j])) } } } const graph = {}; graphList.forEach(({ filename, dependencies, code }) =&gt; { graph[filename] = { dependencies, code } }); return graph; } const generateCode = (entry) =&gt; { const graph = JSON.stringify(analysisDependenciesGraph(entry)); return ` (function(graph){ function require(module) { function localRequire(relativePath) { return require(graph[module].dependencies[relativePath]); } var exports = {}; (function(require, exports, code){ eval(code) })(localRequire, exports, graph[module].code); return exports; }; require(&#39;${entry}&#39;) })(${graph}); `; } const code = generateCode(&#39;./src/index.js&#39;); console.log(highlight(code)); 总结到这里总算是对webpack有了大体的了解了。奈何当我学完webpack后看到了vite这个东西😒。。。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"webpack4.0进阶（二）","slug":"webpack4.0进阶（二）","date":"2020-06-03T07:58:33.000Z","updated":"2020-06-03T07:58:33.000Z","comments":true,"path":"posts/b4c78541/","link":"","permalink":"https://alanwang.site/posts/b4c78541/","excerpt":"TS、Eslint、webpack性能优化","text":"TS、Eslint、webpack性能优化 基础内容打包TS文件使用ts-loader npm i ts-loader typescript -D项目目录如下： ts-test ├── dist │ └── main.js ├── package.json ├── src │ └── index.tsx ├── tsconfig.json └── webpack.config.jstsconfig.json为TS的配置文件，更多配置查看 index.tsx interface person { name: string; ts?: boolean; } function Recruit(personObj:person) : string{ if(personObj.ts) { return `congratulations!${personObj.name}`; } else { return `sorry,${personObj.name}, we need a employee who know ts!`; } } let person1 = {name: &#39;Alan&#39;, age: 21, ts: true}; console.log(Recruit(person1)); let person2 = {name: &#39;Bob&#39;, age: 21}; console.log(Recruit(person2)); tsconfig.json { &quot;compilerOptions&quot;: { &quot;outDir&quot;: &quot;./dist/&quot;, // 由于webpack中配置了，这里可配可不配 &quot;module&quot;: &quot;es6&quot;, &quot;target&quot;: &quot;es5&quot;, &quot;allowJs&quot;: true } } webpack.config.js const path = require(&#39;path&#39;); module.exports = { mode: &#39;production&#39;, entry: &#39;./src/index.tsx&#39;, module: { rules: [ { test: /\\.tsx?$/, exclude: /node_modules/, use: &#39;ts-loader&#39;, } ] }, output: { filename: &#39;[name].js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) } } 当我们项目安装了三方库时并且要在ts文件中使用，得安装该三方库的definitions，具体库可以在TypeSearch查找 devServer.historyApiFallback开发环境下使用单页应用需要配置devServer.historyApiFallback： true EslintEslint是用来统一代码风格的，在团队协作时能够保证每个人书写出的代码风格都是统一的，有利于代码的维护。 使用方式： npm i eslint -D初始化配置 npx eslint --init 初始化配置后我们就可以使用了，这里我安装的是airbnb标准。 上面图片中eslint提示jsx语法不能在js文件中使用，这。。。。😰。那我就是要使用怎么办，可以在生成的.eslintrc.js文件中配置rules忽略这一标准。 rules: { &#39;react/jsx-filename-extension&#39;: 0, }, 由于团队协作很难确保每个人的开发环境都是一样的，于是我们可以把eslint和webpack结合起来，使用一个loader在每次打包时对代码进行eslint检查，但是这样可能会影响打包速度，使用时要对速度和代码质量进行取舍。这里介绍一下使用到的eslint-loader npm i eslint-loader -Dwebpack.common.js配置 rules: [ { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 use: [&#39;babel-loader&#39;, &#39;eslint-loader&#39;], }, ], 当然也可以设置devServer.overlay: true来实现错误实时显示在浏览器上，方便调试。 多页应用打包需要设置多个entry，打包后生成多个.html文件。 src ├── index.html ├── index.js └── list.js// webpack的entry和plugins的配置 entry: { main: &#39;./src/index.js&#39;, // 打包入口文件 list: &#39;./src/list.js&#39;, }, plugins: [ new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, filename: &#39;index.html&#39;, chunks: [&#39;main&#39;], }), new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, filename: &#39;list.html&#39;, chunks: [&#39;list&#39;], }), new CleanWebpackPlugin(), ], 打包后生成的目录 dist ├── index.html ├── list.8c4e5ed5eb6302c4c5ef.js ├── list.8c4e5ed5eb6302c4c5ef.js.map ├── list.html ├── main.acc2939e4489e5d76660.js ├── main.acc2939e4489e5d76660.js.map ├── vendors~list~main.2d42972bf2bf50e6d3cd.js └── vendors~list~main.2d42972bf2bf50e6d3cd.js.map现在只有两个页面还好说，但是当页面一多我们就要配置多个HtmlWebpackPlugin。那如何让它自动配置呢，这里封装一个函数处理一下就好了 const generateHtmlPlugin = (entry) =&gt; { const plugins = [ new CleanWebpackPlugin(), new webpack.ProvidePlugin({ _: &#39;lodash&#39;, }), ]; Object.keys(entry).forEach((item) =&gt; { plugins.push( new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, filename: `${item}.html`, chunks: [item], }), ); }); return plugins; }; webpack完整配置（webpack.common.js） const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;); const webpack = require(&#39;webpack&#39;); const generateHtmlPlugin = (entry) =&gt; { const plugins = [ new CleanWebpackPlugin(), new webpack.ProvidePlugin({ _: &#39;lodash&#39;, }), ]; Object.keys(entry).forEach((item) =&gt; { plugins.push( new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, filename: `${item}.html`, chunks: [item], }), ); }); return plugins; }; const configs = { mode: &#39;development&#39;, // 默认为production entry: { main: &#39;./src/index.js&#39;, // 打包入口文件 list: &#39;./src/list.js&#39;, }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 use: [&#39;babel-loader&#39;], }, ], }, optimization: { usedExports: true, splitChunks: { chunks: &#39;all&#39;, }, }, output: { path: path.resolve(__dirname, &#39;dist&#39;), }, }; configs.plugins = generateHtmlPlugin(configs.entry); module.exports = configs; webpack性能优化Loader 减少使用不必要的Loader 合理使用exclude和include来针对性的使用loader Plugin 减少不必要的plugin的使用 Resolve（偷懒用的？😂） 减少extensions的使用 减少mainFiles的使用 减少alias的使用 extensions的使用 配置了extensions后可以不写扩展名🤣 目录文件 webpacktest ├── package.json ├── src │ ├── index.html │ ├── index.js │ └── tool │ └── tool.jsx ├── webpack.common.js ├── webpack.dev.js └── webpack.prod.jswebpack.config.jsindex.jstool.jsxresolve: { extensions: ['.js', '.jsx'], },import tool from './tool/tool'; tool();export default function Tool() { console.log('my tool'); } 设置了extensions后，webpack由于找不到./tool/tool会先去寻找./tool/tool.js，如果没找到再去寻找./tool/tool.jsx。 mainFiles的使用 配置了mainFiles后可以不写默认文件（说白了就是偷懒😎） 修改index.js文件 import tool from &#39;./tool/&#39;; tool(); webpack配置 resolve: { extensions: [&#39;.js&#39;, &#39;.jsx&#39;], mainFiles: [&#39;index&#39;, &#39;tool&#39;], }, 设置了mainFiles后，webpack会先去寻找./tool/index.js和./tool/index.jsx ，如果没找到再去寻找./tool/tool.js和./tool/tool.jsx。 alias的使用 偷懒神器，免去写长长的路径。 修改index.js文件 import tool from &#39;myTool&#39;; //这里使用的是别名alias tool(); webpack配置 resolve: { extensions: [&#39;.js&#39;, &#39;.jsx&#39;], mainFiles: [&#39;index&#39;, &#39;tool&#39;], alias: { myTool: path.resolve(__dirname, &#39;./src/tool/tool.jsx&#39;), }, }, 这样就可以使用别名myTool来直接引用tool.jsx文件了。 DllPlugin优化项目中第三方模块的打包速度 多进程打包多进程打包插件有：thread-loader，parallel-webpack，happypack sourceMap根据不同环境来配置不同的sourceMap最大程度上优化打包速度 status.json通过status.json文件来分析打包过程，找到最影响性能的地方对症下药。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"前端面试题","slug":"前端面试题","date":"2020-05-31T08:41:48.000Z","updated":"2020-07-24T07:03:00.000Z","comments":true,"path":"posts/20802113/","link":"","permalink":"https://alanwang.site/posts/20802113/","excerpt":"记录了自己疫情期间自学+复习总结的一些面试题+面试遇到的一些问题，文章将会持续更新。","text":"记录了自己疫情期间自学+复习总结的一些面试题+面试遇到的一些问题，文章将会持续更新。 背景 由于今年疫情的原因以及一些个人原因，辞去了之前的实习工作。在家待了也快5个月了(期间经历了毕业设计+毕业答辩（2个月），算下来已经有3个月没有上班了😭)。去年在公司实习错过了秋招，今年又碰上疫情，对我这个应届生来说简直是难上加难。在家这段时间自己学习了React、webpack。用React搭建了一直想做但是耽搁了半年的博客，搭建出来后考虑后期维护成本（服务器费用），就没有继续维护了。改用了Hexo+github搭建了一个静态博客。真香😂。 JS原型及继承 组合继承 function Person(name) { this.name = name; this.features = [&#39;eyes&#39;]; } function Student(name, id) { Person.call(this, name); //继承属性相当于super(this) this.id = id; } Student.prototype = new Person(); Student.prototype.sayHello = function () { console.log(&#39;hello&#39;); }; const s1 = new Student(&#39;Alan&#39;, &#39;001&#39;); const s2 = new Student(&#39;Bob&#39;, &#39;002&#39;); console.log(s1 instanceof Person); // true // 引用类型在各实例中不会相互影响 s1.features.push(&#39;hand&#39;); console.log(s2.features); // [&quot;eyes&quot;] 更多继承方式及其优缺点可以查看红宝书第六章（讲得非常“干”） 深拷贝和浅拷贝在JS中，变量分为了基本类型和引用类型。对基本类型进行赋值时是对值进行拷贝的，而对引用类型进行赋值则是对地址进行拷贝。 基本类型引用类型let a = 1; let b= a; console.log(a); // 1 a++; console.log(a); // 2 console.log(b); // 1const obj = { name: 'Alan', age: 22, } const cloneObj = obj; obj.age = 18; console.log(cloneObj.age); // 18 通过上面的例子我们知道，cloneObj和obj是指向同一个地址的，任何一方修改都会影响到对方，那如何创建一个独立的cloneObj?，这就要使用深拷贝和浅拷贝了。 深拷贝和浅拷贝的区别： 根据拷贝的层级进行区分，浅拷贝只进行一层拷贝，深拷贝进行多层拷贝。 浅拷贝 方法1方法2const obj = {a:1, b:{b1:1, b2:2}, c:0}; function shallowClone(source) { const result= {}; for (const key in source) { if (source.hasOwnProperty(key)) { result[key] = source[key]; } } return result; } const shallowObj = shallowClone(obj); obj.a = 10; console.log(shallowObj.a); // 1 obj.b.b1 = 6; console.log(shallowObj.b.b1); // 6const obj = {a:1, b:{b1:1, b2:2}, c:0}; function shallowClone1(source) { return Object.assign({}, source); } const shallowObj = shallowClone1(obj); obj.a = 10; console.log(shallowObj.a); // 1 obj.b.b1 = 6; console.log(shallowObj.b.b1); // 6 深拷贝 方法1方法2const obj = {a:1, b:{b1:1, b2:2}, c:0}; function deepClone(source) { const result = {}; for (const key in source) { if (source.hasOwnProperty(key)) { if (typeof source[key] === 'object') { result[key] = deepClone(source[key]); } else { result[key] = source[key]; } } } return result; } const deepObj = deepClone(obj); obj.a = 10; console.log(deepObj.a); // 1 obj.b.b1 = 6; console.log(deepObj.b.b1); // 1const obj = {a:1, b:{b1:1, b2:2}, c:0}; function deepClone(source) { return JSON.parse(JSON.stringify(source)); } const deepObj = deepClone(obj); obj.a = 10; console.log(deepObj.a); // 1 obj.b.b1 = 6; console.log(deepObj.b.b1); // 1 数组去重方法1方法2方法3 Set// 笨方法 const arr = [1,3,45,6,3,2,0]; const newArr = []; let isRepeat; for (let i = 0; i &lt; arr.length; i++) { isRepeat = false; for (let j = 0; j &lt; newArr.length; j++) { if (arr[i] === newArr[j]) { isRepeat = true; break; } } if (!isRepeat) { newArr.push(arr[i]); } } console.log(arr); // [1, 3, 45, 6, 3, 2, 0] console.log(newArr); // [1, 3, 45, 6, 2, 0]const arr = [1,3,45,6,3,2,0]; const newArr = arr.filter((item,index) =&gt; { return arr.indexOf(item) === index }) console.log(arr); // [1, 3, 45, 6, 3, 2, 0] console.log(newArr); // [1, 3, 45, 6, 2, 0]const arr = [1,3,45,6,3,2,0]; const newArr = [...new Set(arr)]; console.log(arr); // [1, 3, 45, 6, 3, 2, 0] console.log(newArr); // [1, 3, 45, 6, 2, 0] for in 和 for of for in 会遍历数组中的可枚举属性，包括原型。可以遍历对象，遍历的是key值 for of只是遍历数组的元素或者可以迭代的对象，不包括原型。遍历的是value值。 Array.prototype.testMethod = function () { console.log(&#39;testMethod&#39;); } const mArr = [1,2,3,7]; const mObject = { name: &#39;Alan&#39;, age: 1 } for (const key in mArr) { console.log(mArr[key]); // 1 2 3 7 /* ƒ () { console.log(&#39;testMethod&#39;); } */ } // 解决方案 for (const key in mArr) { if (mArr.hasOwnProperty(key)) { console.log(mArr[key]); // 1 2 3 7 } } for (const key in mObject) { console.log(key); // name // age } try { for (const iterator of mObject) { console.log(iterator); } } catch (error) { console.log(error); //mObject is not iterable } 事件委托事件委托利用了事件冒泡，只指定了一个事件处理程序，就可以管理某一类型的所有事件。 例如，click事件会一直冒泡到document层次。例如下面例子中我们无需对所有li元素添加onclick事件，只需使用事件冒泡的特性来实现事件委托。 &lt;body&gt; &lt;ul id=&quot;myList&quot;&gt; &lt;li id=&quot;sayName&quot;&gt;Name&lt;/li&gt; &lt;li id=&quot;sayHello&quot;&gt;Hello&lt;/li&gt; &lt;li id=&quot;sayAge&quot;&gt;Age&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; const myList = document.getElementById(&#39;myList&#39;); myList.addEventListener(&#39;click&#39;, function (e) { const target = e.target; if (target.id === &#39;sayName&#39;) { alert(&#39;Alan&#39;); } else if(target.id === &#39;sayHello&#39;) { alert(&#39;Hello&#39;); } else { alert(&#39;sayAge&#39;); } }) &lt;/script&gt; &lt;/body&gt; 实现滑动动画&lt;div id=&quot;myDiv&quot;&gt;&lt;/div&gt; &lt;script&gt; const myDiv = document.getElementById(&#39;myDiv&#39;); const time = Date.now(); //时间戳 const transition = setInterval(() =&gt; { const timeLength = Date.now() - time; const step = (5000 - timeLength) / 1000; console.log(step); if (timeLength &gt; 5000) { clearInterval(transition); // 5s后结束 } myDiv.style.left = myDiv.offsetLeft + step + &#39;px&#39;; }, 50); &lt;/script&gt; 数组扁平化方法1方法2方法3方法4// 笨方法：遍历 const arr = [1,2,7,[2,[2,3],6]]; function flat(arr) { let result = []; for (let i = 0; i &lt; arr.length; i++) { if(Array.isArray(arr[i])) { result = result.concat(flat(arr[i])); } else { result.push(arr[i]); } } return result; } console.log(flat(arr));// 使用for of let arr = [1,2,7,[2,[2,3],6]]; function flat(arr) { let newArr =[]; for (const item of arr) { if(Array.isArray(item)){ newArr = newArr.concat(flat(item)); } else { newArr.push(item); } } return newArr; } console.log(flat(arr));const arr = [1,2,7,[2,[2,3],6]]; function flat(arr) { while (arr.some(item =&gt; Array.isArray(item))) { arr = [].concat(...arr); } return arr; } console.log(flat(arr));// 骚操作 const arr = [1,2,7,[2,[2,3],6]]; function flat(arr) { const result = arr.toString().split(',').map(item =&gt; { return +item; }); return result; } console.log(flat(arr)); eventLoopJS是单线程的，那为什么不是多线程的呢，设想一个场景，一个线程修改了body的background为red，另一个线程修改了body的background为green。那最终浏览器就不知道background到底为什么。由此可以看到多线程会为浏览器的DOM操作带来很多同步问题。参考资料 JS的任务可以分为同步任务和异步任务。 1.同步任务优先在主线程上执行，会形成一个执行栈。 2.异步任务会被放入任务队列中，当执行栈清空时会读取任务队列中的任务丢进执行栈中。 1、2两步反复执行形成了eventLoop。 如果将任务细分的话还可以分成宏任务和微任务： macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise.then()，process.nextTick 优先级：process.nextTick&gt;Promise.then() 当执行栈中没有任务时，微任务总是优先于宏任务执行 详细查看文章这一次，彻底弄懂 JavaScript 执行机制 this 指向调用它的那个对象，函数运行时获得的。 箭头函数的this指向取决于定义时最近一层的非箭头函数的this值。取决于外部的上下文。 闭包 当前函数的执行上下文中的内容被该上下文以外的内容占用，导致当前上下文无法释放。 闭包是指有权访问另一个函数作用域中的变量的函数。 创建闭包的常见方式，就是在一个函数内部创建另一个函数 涉及到函数作用域链，词法作用域，后期有空再补充 求数组最大值const arr = [1,2,1,4,2,10]; console.log(Math.max.apply(null, arr)); const arr = [1,2,1,4,2,10]; console.log(arr.sort((a,b) =&gt; (a-b))[arr.length-1]); const arr = [1,2,1,4,2,10]; console.log(Math.max(...arr)); Promise// new Promise(executor)，当new Promise被创建，executor自动执行 let promise = new Promise(function (resolve, reject) { resolve(&#39;finished&#39;); // reject(new Error); }); // Promise.then(f1,f2) f1在resolve后运行（参数为resolve结果），f2在reject后运行（参数为reject错误） promise.then( result =&gt; console.log(result), //finished error =&gt; console.log(error) //输出错误 ); promise.all()同时执行多个promise，只要有一个promise被reject，那么将不再执行 promise.allSettled()和promise.all()类似，只是会等所有promise执行完。 promise.race()返回最快执行完的promise结果。 实现一个sleep function sleep(ms) { return new Promise((resolve) =&gt; { setTimeout(resolve, ms); }); } (async () =&gt; { console.log(&#39;2s后输出内容...&#39;); await sleep(2000); console.log(&#39;666&#39;); })(); https://zh.javascript.info/promise-basics 防抖和节流 节流 函数在一定时间内只执行一次，比如点击按钮后回去服务器获取数据，使用节流可以防止短时间内请求多次，减少服务器的压力 防抖 在一定时间后才执行（触发多次只会执行一次）。应用场景：input搜索框在wait秒后再发送请求 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body { height: 4000px; width: 100px; background: rgb(241, 165, 165); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;fetchBtn&quot;&gt;fetch data&lt;/button&gt; &lt;span&gt;searchBar&lt;/span&gt;&lt;input id=&quot;inputBar&quot;/&gt; &lt;script&gt; // 节流 function throttle(func, wait) { let last = 0; return function (...args) { let now = new Date(); if (now - last &gt; wait) { last = now; func.apply(this, args); } } } // 防抖 function debounce(func, wait) { let timer = 0; return function (...args) { if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; { func.apply(this, args); }, wait) } } document.getElementById(&#39;fetchBtn&#39;).addEventListener(&#39;click&#39;, throttle(function (numb) { console.log(&#39;fetching&#39;); },1000)); document.getElementById(&#39;inputBar&#39;).addEventListener(&#39;input&#39;, debounce(function (numb) { console.log(&#39;searching&#39;); },1000)); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; XMLHttpRequest常用方法： open(method, url, [async, user, password])初始化，async(false/true)控制同步/异步 send([body])发送请求 abort()中止请求 setRequestHeader(name, value)设置请求头 常用属性： status: 404/200… statusText: Not Found/OK… responseType: 响应格式 readyState： 状态 withCredentials: 跨域设置 UNSENT = 0; // 初始状态 OPENED = 1; // open 被调用 HEADERS_RECEIVED = 2; // 接收到 response header LOADING = 3; // 响应正在被加载（接收到一个数据包） DONE = 4; // 请求完成 常用监听事件： onload onerror onprogress 题目const a = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;].map(parseInt); // 数组a中的&#39;1&#39;转化为10进制。 console.log(a); // [1, NaN, NaN] // map的三个参数(item,index,array) /* parseInt(string, radix) 当radix等于0或者undefined或者没有指定时，如果string以&#39;0x&#39;或者&#39;&#39;0X&#39;开头，则radix=16 以&#39;0&#39;开头，根据实际情况radix=10/8。 */ const users = [ { name: &#39;Alan&#39;, age: 19 }, { name: &#39;Bob&#39;, age: 25 } ]; const userList = users.sort((a, b) =&gt; b.age-a.age); // 根据年龄进行排序，注意：sort会改变原来的数组 function isSameLetter(a, b) { a = a.toString().toLowerCase(); b = b.toString().toLowerCase(); return a.split(&#39;&#39;).sort().join(&#39;&#39;) === b.split(&#39;&#39;).sort().join(&#39;&#39;); } console.log(isSameLetter(&#39;176as&#39;, &#39;a17s6&#39;)); //判断两者是否是由相同的字母组成，顺序可以不一样 CSScss单位 rem：相对于根元素的字体大小（html）css3 如果html的font-size为16px（默认），那么1rem=16px em：如果该元素有设置font-size，那么相对于该元素。如果没有设置则相对于父元素。 例如，div设置了font-size为10px，那么该div中使用em时，1em为10px 如果该元素没有设置font-size且父元素设置font-size为20px，那么1em为20px vh/vw相对于视窗，10vh=1/10的屏幕高 translate和使用绝对定位的区别translate会占据原来的位置，绝对定位会脱离文档流。 BFC概念：很模糊抽象，是页面上一个隔离的独立容器，容器中的子元素不会影响到外面的元素。 试用场景：清理浮动，解决margin重叠 一个元素不能同时存在两个BFC中 创建方式： 根元素 float不为none position: absolute/fixed display: inline-block/table-cell overflow不为visible 弹性盒子（display: flex/inline-flex） 清理浮动 伪类元素 .clearfix::after { content: &#39;&#39;; display: blcok; clear: both; } 创建BFC overflow: hidden; overflow: auto; 空盒子 &lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt; 选择器优先级!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 垂直居中&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt; table-cell .outer { width: 400px; height: 400px; background: aqua; display: table-cell; vertical-align: middle; text-align: center; } .inner { width: 100px; height: 100px; background: brown; display: inline-block; } flex布局 绝对定位 已知子元素宽高未知子元素宽高margin.outer { position: relative; } .inner { position: absolute; left: 50%; top: 50%; margin-left: -50px; /* 宽度一半 */ margin-top: -50px; /* 高度一半 */ }.outer { position: relative; } .inner { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); }.outer { position: relative; } .inner { position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto; } HTMLmeta标签&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;网络从输入URL到页面加载发生了什么 浏览器查找当前URL是否存在缓存，并比较缓存是否过期 根据DNS解析得到IP地址 建立TCP连接（3次握手） HTTP发请求 服务器处理请求，返回数据 渲染页面，构建DOM树 关闭TCP连接（4次挥手） 常用状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 状态码 描述 200 请求成功 204 无内容。服务器成功处理，但未返回内容 301 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 304 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 400 客户端请求的语法错误，服务器无法理解 401 请求要求用户的身份认证 403 服务器理解请求客户端的请求，但是拒绝执行此请求 404 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 500 服务器内部错误，无法完成请求 网络七层协议引用网上的一张图，如侵权请联系我删除😂 引自维基百科TCP/IP协议族是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。这个协议族由互联网工程任务组负责维护。 TCP（Transmission Control Protocol 传输控制协议）:通过三次握手与服务器建立一个全双工的通信，在数据传送之前把数据分割成IP包，在到达服务器时再将他们重组。 IP（Internet Protocol 网际协议）:IP负责客户端与服务端之间的通信，IP负责在因特网上发送和接受数据包。通过IP，数据被分割成小的独立的包，然后通过互联网在计算机之间传送。 HTTPHTTP(HyperText Transfer Protocol)，基于TCP实现的应用层协议。HTTP是一个无状态的协议，即客户端和服务端之间不用建立持久的链接，当客户端发送一个请求，服务端返回响应时，连接就被关闭了。 当请求一个url时www.baidu.com，首先DNS解析出该地址对应的IP地址，然后将相关信息封装成一个HTTP请求数据包。然后TCP（三次握手）建立连接，连接成功后发送HTTP请求，服务端响应回来后，关闭TCP连接。如果浏览器或服务器在头部加入了Connection:keep-alive，那么TCP在发送完信息后仍然保存连接，这样可以减少TCP连接次数，能提升性能和服务器吞吐率。 缺点： 通行使用明文，不安全 不验证身份，可能遭遇伪装 无法验证报文完整性，可能遭遇篡改 前面提到了HTTP是一个无状态的协议，那如何让它拥有状态？ session和cookie cookie(key/value形式): 客户端返回cookie附在响应头中的Set-Cookie或者Set-Cookie2，cookie保存在客户端，下次访问时连同cookie发送给服务端 cookie的同源和跨域: cookie只关注域名，忽略协议和端口，意思是协议或者端口不同不属于跨域 session机制（服务端维护的），基于cookie工作： session和sessionId（返回给客户端） 当客户端访问服务端时，首先检查请求中是否包括sessionId。如果有，通过sessionId检索出对应session进行一系列操作。如果没有sessionId，创建一个session以此对应的sessionId通过cookie存在客户端，客户端之后访问服务端时通过这个sessionId维护HTTP状态。 HTTPSHTTPS = HTTP + TLS/SSL 经过加密的HTTP，更加安全，利用SSL/TLS加密数据包； TLS/SSL:安全传输层协议Transport Layer Security TSL/SSL涉及到三种算法： 散列函数Hash：MD5、SHA1、SHA256（函数单向不可逆，加密传输信息以及信息摘要） 对称加密：AES-CBC、DES、3DES、AES-GCM 非对称加密：RSA（分公钥和私钥） TSL工作方式： 首先使用非对称加密算法加密进行通信，服务端返回公钥并协商使用对称加密后的密钥对通信进行加密。 RSA存在的隐患： 无法确保服务器身份的合法性（因为公钥不包含服务器信息）： 例如： C（客户端）和S（服务端）通信时，H（劫持者）截获了S与C的通信，H将自己的公钥pub_H给了C，当C向S发送请求时，实际上是使用pub_H加密的，这样H就能获取到C发送的消息了。这样原本属于C和S的通信现在就变成了C和H的通行了。 解决方案：引入第三方认证机构，验证公钥拥有者的信息然后颁发证书，简称PKI体系 - S向第三方机构提交公钥和公司相关信息 - CA（即三方认证机构）通过一系列渠道验证审核S信息的正确性 - 审核通过后，CA向S签发证书，证书信息包括：S的公钥、S公司相关信息、签发机构CA的信息、有效时间、证书序列号（前面这些信息全是明文显示）。签名（使用散列函数计算公开的明文信息的信息摘要，然后用CA的私钥对信息摘要加密） - C向S发送请求，S返回证书 - C读取证书中的明文信息，采用相同的散列函数计算得到信息摘要，然后利用CA对应的公钥对签名进行解密，对比证书中的信息摘要来验证证书/公钥的合法性。跨域非同源请求，均为跨域。名词解释：同源 —— 如果两个页面拥有相同的协议（protocol），端口（port）和主机（host），那么这两个页面就属于同一个源（origin）。 jsonp: 通过script标签的src属性来实现 CORS: 服务端设置Access-Control-Allow-Origin和Access-Control-Allow-Credentials为true Vue设置跨域： vue.http.options.credentials = true Nginx代理 框架单页应用优缺点优点： 基于ajax加载数据，无需刷新页面，用户体验好 前后端分离，后端代码可以应用到多端 减轻服务器压力 缺点： 不利于SEO，可以使用SSR解决 首屏加载速度慢 不支持浏览器前进后退功能","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"面试造轮","slug":"前端/面试造轮","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%80%A0%E8%BD%AE/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://alanwang.site/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"webpack4.0进阶（一）","slug":"webpack4.0进阶（一）","date":"2020-05-25T06:43:46.000Z","updated":"2020-05-30T09:20:00.000Z","comments":true,"path":"posts/84d16999/","link":"","permalink":"https://alanwang.site/posts/84d16999/","excerpt":"webpack4.0进阶学习","text":"webpack4.0进阶学习 Tree Shaking按需打包文件index.jsmoment.jsimport { used } from './moment'; used();export function used() { console.log('used function'); } export function notUsed() { console.log('notUsed funtion'); } 上面这个例子中我们只使用到了moment中的used，但是打包后连同notUsed一起被打包进了main.js文件中 Tree Shaking可以帮我们解决这个问题。 注意：1.Tree Shaking只在production模式下生效。2.只支持ES Module 语法（import），不支持CommonJs package.jsonwebpack.config.js\"sideEffects\": false, 或者 \"sideEffects\": [ \"**/*.css\", \"**/*.scss\", \"./esnext/index.js\", \"./esnext/configure.js\" ], 意思是对这些文件不进行tree shaking处理 例如 import './common.css'; 虽然我们没有使用common.css的一些东西，但是它起到了样式的作用的，如果不在sideEffect中设置的话，webpack是不会对它进行打包的。optimization: { usedExports: true, } // production模式是会自动配置好，可写可不写 开发环境和生产环境配置文件由于开发环境需要调试代码所以会引入devServer之类的插件，那么这部分插件在生产环境中是不需要使用到的，我们可以对开发环境和生产环境分别设置不同的配置文件。 首先安装插件webpack-merge用来将拼接common配置 npm i webpack-merge -D目录如下： webpacktest ├── package.json ├── src │ ├── index.html │ ├── index.js │ └── moment.js ├── webpack.common.js ├── webpack.dev.js └── webpack.prod.jswebpack.common.js const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;); module.exports = { mode: &#39;development&#39;, // 默认为production entry: { main: &#39;./src/index.js&#39;, // 打包入口文件 }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 loader: &#39;babel-loader&#39; }, { test: /\\.css$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;], }, ], }, output: { // 输出文件配置 filename: &#39;[name].js&#39;, path: path.resolve(__dirname, &#39;dist&#39;), }, optimization: { usedExports: true, }, plugins: [ new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39;, }), new CleanWebpackPlugin(), ], }; webpack.dev.js const merge = require(&#39;webpack-merge&#39;); const commonConfig = require(&#39;./webpack.common.js&#39;); const devConfig = { mode: &#39;development&#39;, // 默认为production devtool: &#39;cheap-module-eval-source-map&#39;, devServer: { contentBase: &#39;./dist&#39;, open: true, // 自动打开浏览器 port: 3001, // 服务器端口号 hot: true, // 开启HRM } }; module.exports = merge(commonConfig, devConfig); webpack.prod.js const merge = require(&#39;webpack-merge&#39;); const commonConfig = require(&#39;./webpack.common.js&#39;); const prodConfig = { mode: &#39;development&#39;, // 默认为production devtool: &#39;cheap-module-source-map&#39; }; module.exports = merge(commonConfig, prodConfig); npm script &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;, &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot; }, 配置好后，开发环境使用npm run dev进行打包，生产环境用npm run build进行打包。 代码分割代码分割有利于性能的优化。何为代码分割： 有这么一个场景，我在index.js中使用到了一些公共代码库/工具库（lodash），index.js中的代码是依赖于lodash中的一些工具的。当我们打包时，lodash也是被打包到了main.js文件中，并且一旦index.js中的业务代码改变了，连同lodash也要一同重新打包加载，但是我们一般是不会去改动lodash这类工具库的。于是我们可以借助代码分割来将业务代码和lodash进行分割，这样下次再修改业务代码时，我们就无需重新加载lodash的内容了。 先安装lodash npm i lodash -S这里为了便于查看打包后的文件内容，我们加上一条npm script&quot;start&quot;: &quot;webpack --config webpack.dev.js&quot;(由于devServer不会生成打包内容) index.js import _ from &#39;lodash&#39;; console.log(_.compact([0, 1, false, 2, &#39;&#39;, 3])); npm run start打包，发现打包后的main.js文件中包含lodash内容。 那如何实现代码分割呢，只需配置webpack.common.js文件 optimization: { splitChunks: { chunks: &#39;all&#39; } } 再次打包，发现打包后的文件中多了一个vendor~main.js，webpack自动将lodash内容打包进去了，而main.js文件中就没有了lodash的内容了。 dist ├── index.html ├── main.js └── vendors~main.js上面介绍的时同步代码分割，下面看一下异步代码分割index.js，可以实现懒加载 async function createElement() { const { default: _ } = await import(/* webpackChunkName: &quot;lodash&quot; */&#39;lodash&#39;); const element = document.createElement(&#39;div&#39;); element.innerHTML = _.compact([0, 1, false, 2, &#39;&#39;, 3]); return element; } document.addEventListener(&#39;click&#39;, () =&gt; { createElement().then(element =&gt; { document.body.appendChild(element); }) }) /* webpackChunkName: &quot;lodash&quot; */设置打包后的文件名为vendors~lodash.js，打开浏览器可以看到只有点击页面时，才会引入vendors~lodash.js，实现了懒加载。 打包后的目录 dist ├── index.html ├── main.js ├── vendors~lodash.js └── vendors~main.js当然可以通过其他配置来设置打包后的文件名称。 代码分割更多配置 打包分析工具首先要拿到status.json文件，具体获取方式只需配置npm script即可 &quot;start&quot;: &quot;webpack --profile --json &gt; status.json --config webpack.dev.js&quot;, 打包后会生成status.json文件。 然后使用官网提供的一些工具就可以可视化分析打包结果了。 在写代码时，我们要尽可能的使用异步引入，这样可以提高代码的使用率，提升性能，减少加载不必要的代码。 查看代码使用率的方法，浏览器控制台按下ctrl+shift+p，输入show coverage 代码优化现在有一个优化场景，我有一个登录按钮，当点击按钮后弹出登录框。这里的优化思路是，页面加载时只加载登录按钮的代码，当按钮代码加载完后。利用空闲时间去加载登录框的代码。这样既可以优化首屏加载速度，还可以解决因使用懒加载登录框（也就是点击按钮后再去加载）而带来的用户体验较差的问题。 具体代码：(只需要在import中加入/* webpackPrefetch: true */) index.js document.addEventListener(&#39;click&#39;, () =&gt; { import(/* webpackPrefetch: true */&#39;./loginModal.js&#39;).then(({default: login}) =&gt; { login(); }) }) loginModal.js export default function () { alert(&#39;loginModal&#39;); } css文件处理MiniCssExtractPlugin This plugin should be used only on production builds without style-loader in the loaders chain, especially if you want to have HMR in development. 官方推荐不要在开发环境中使用，因为不支持HMR，不利于提高开发效率。 npm install --save-dev mini-css-extract-pluginindex.js import &#39;./style.css&#39;; style.css body { background: #e65; } webpack.common.jswebpack.dev.jswebpack.prod.jspackage.jsonconst path = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const { CleanWebpackPlugin } = require('clean-webpack-plugin'); module.exports = { mode: 'development', // 默认为production entry: { main: './src/index.js', // 打包入口文件 }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 loader: 'babel-loader', }, ], }, output: { // 输出文件配置 filename: '[name].js', chunkFilename: '[name].chunk.js', path: path.resolve(__dirname, 'dist'), }, plugins: [ new HtmlWebpackPlugin({ template: './src/index.html', }), new CleanWebpackPlugin(), ], optimization: { usedExports: true, splitChunks: { chunks: 'all', }, }, };const merge = require('webpack-merge'); const commonConfig = require('./webpack.common.js'); const devConfig = { mode: 'development', devtool: 'cheap-module-eval-source-map', devServer: { contentBase: './dist', open: true, // 自动打开浏览器 port: 3001, // 服务器端口号 hot: true, // 开启HRM }, module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'], } ], }, }; module.exports = merge(commonConfig, devConfig);const merge = require('webpack-merge'); const commonConfig = require('./webpack.common.js'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const prodConfig = { mode: 'development', devtool: 'cheap-module-source-map', module: { rules: [ { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'], } ], }, plugins: [ new MiniCssExtractPlugin({}) ] }; module.exports = merge(commonConfig, prodConfig);\"sideEffects\": [ \"*.css\" ], 也可以使用optimize-css-assets-webpack-plugin来压缩css代码 配置output解决浏览器cache问题浏览器是有缓存功能的，在我们第一次加载main.js后，浏览器会保有main.js的缓存，下次再加载时就直接从缓存获取了。但是当我们下次发布新版本时（修改了main.js文件），浏览器还是使用以前缓存的main.js内容，所以显示的内容并不是最新的。 处理方法 设置output的filename，添加[contenthash]占位符。 output: { // 输出文件配置 filename: &#39;[name].[contenthash].js&#39;, chunkFilename: &#39;[name].[contenthash].js&#39;, }, shimming看一个场景，假设library.js是一个比较老的第三方库。 index.jslibrary.jsimport './style.css'; import { createText } from './library'; createText();// 这个第三方库中使用到了loadsh，但是并没有引入lodash export function createText() { document.getElementById('root').innerHTML = _.compact([0, 1, false, 2, '', 3]); } npm run dev打包后浏览器报错 Uncaught ReferenceError: _ is not defined 如果library.js是我们自己写的库那还好说，直接自己手动引入lodash就可以了。但是由于是第三方库，源文件是在node_module中的，不利于修改，这个时候就可以用shimming来解决了。 配置webpack.common.js // 记得引入const webpack =require(&#39;webpack&#39;); // 下面代码的意思：当遇到_时，会自动为我们添加下面代码 // import _ from &#39;lodash&#39; plugins: [ new webpack.ProvidePlugin({ _: &#39;lodash&#39; }) ], 更多配置参考shimming 细粒度 shimming 试着在index.js中打印出this，发现this其实是指向模块本身。那如何把this指向window呢，这里要借助imports-loader npm i imports-loader -D配置好loader rules: [ { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 use: [ { loader: &#39;babel-loader&#39;, }, { loader: &#39;imports-loader?this=&gt;window&#39; } ] }, ] 总结 Tree Shaking可以实现对js文件的按需打包，只在production下生效。 为生产和开发环境分别创建不同配置文件。 利用代码分割实现懒加载（利用魔法注释）。 利用status.json来分析打包过程。 单独生成css文件，减少mian.js体积。 为output文件设置hash值，防止浏览器使用缓存。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"记录生活2020/5","slug":"记录生活2020-5","date":"2020-05-22T14:50:26.000Z","updated":"2020-05-22T14:50:26.000Z","comments":true,"path":"posts/66d3b164/","link":"","permalink":"https://alanwang.site/posts/66d3b164/","excerpt":"这是一篇记录5月生活的个人随记。📝","text":"这是一篇记录5月生活的个人随记。📝 2020-05-22现在是22:53，我的论文初稿终于上传审核了🎈，查重率4.8%。记录一下，后天就要线上答辩了。","categories":[{"name":"记录生活","slug":"记录生活","permalink":"https://alanwang.site/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"},{"name":"2020","slug":"记录生活/2020","permalink":"https://alanwang.site/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/2020/"}],"tags":[{"name":"记录生活","slug":"记录生活","permalink":"https://alanwang.site/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"}]},{"title":"webpack4.0学习总结（四）","slug":"webpack4.0学习总结（四）","date":"2020-05-18T02:24:19.000Z","updated":"2020-05-20T07:19:00.000Z","comments":true,"path":"posts/35b500c6/","link":"","permalink":"https://alanwang.site/posts/35b500c6/","excerpt":"webpack的devServer热更新以及HMR局部热更新","text":"webpack的devServer热更新以及HMR局部热更新 DevServerDevServer可以起一个本地服务并且实现代码的热更新。可以省去我们每次更新代码后重启服务额操作。 npm i webpack-dev-server -D配置文件 package.json &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot;, &quot;start&quot;: &quot;webpack-dev-server&quot; }, webpack.config.js devServer: { contentBase: &#39;./dist&#39;, open: true, // 自动打开浏览器 port: 3001, // 服务器端口号 }, 我们之后只需要使用npm run start就可以把服务跑起来了，之后只要改动代码就会自动更新了，开发效率提高了很多有没有😝 devServer更多配置内容 HMR实现局部热更新HMR（Hot Module Replacement） 当我们更改了部分文件后，我们发现webpack-dev-server帮我们重新渲染所有内容，假如我只改动了一小部分，只想更新这一部分内容就可以用了使用HMR来实现了。 说再多不如看一个例子 index.js import &#39;./index.css&#39;; var root = document.getElementById(&#39;root&#39;); root.innerHTML = &#39;&lt;button id=&quot;btn&quot;&gt;add new block&lt;/button&gt;&#39;; document.getElementById(&#39;btn&#39;).onclick = function() { var newBlock = document.createElement(&#39;p&#39;); newBlock.innerHTML = &#39;new Block&#39;; root.append(newBlock); } index.css p { width: 100px; } p:nth-child(6) { background: red; } 这里例子就是点击按钮添加一个p元素，第6个p元素显示为红色背景 这个时候我觉得红色不好看，想换成黄色，修改，保存一气呵成。 结果webpack-dev-server给我全部重新渲染了，我还要再点6下才能看到效果，这里如果是1000（虽然不太可能）呢，那我岂不是要点1000下😱。 这个时候配置HRM就可以轻松解决这个问题了。 只需要再webpack.config.js中配置 devServer: { contentBase: &#39;./dist&#39;, // Tell the server where to serve content from open: true, // 自动打开浏览器 port: 3001, // 服务器端口号 hot: true, // 开启HRM }, 搞定😎，不过这里由于有css-loader帮我们做了一些更新的任务，所以我们并没有写过多的代码。那如果没有css-loader处理那怎么办？下面看一下具体配置。 index.jscounter.jsnumber.jsimport Counter from './counter' import Number from './number' Counter(); Number();function Counter() { var root = document.getElementById('root'); var counter = document.createElement('div'); counter.innerHTML = 0; counter.onclick = function () { counter.innerHTML = parseInt(counter.innerHTML, 10) + 1; } root.append(counter); } export default Counter;function Number() { var root = document.getElementById('root'); var data = document.createElement('div'); data.setAttribute('id', 'number'); data.innerHTML = '2000'; root.append(data); } export default Number; 可以看到当我一改变number，counter中的状态又重新渲染变成0了😩。 这里我们就要通过一部分代码来处理一下了（css-loader就是帮我们完成了这部分工作） import Counter from &#39;./counter&#39; import Number from &#39;./number&#39; Counter(); Number(); if (module.hot) { // 如果开启HMR module.hot.accept(&#39;./number.js&#39;, () =&gt; { var root = document.getElementById(&#39;root&#39;); root.removeChild(document.getElementById(&#39;number&#39;)); console.log(&#39;number is updated&#39;); Number(); // 一旦number.js文件改变，进行一系列处理 }) } HMR详细文档 处理ES6语法我们先用ES6写一些代码 const name = &#39;Alan&#39;; const list = [1, 8, 4, 6]; const resultList = list.filter(item =&gt; item &gt; 5); new Promise(() =&gt; { console.log(&#39;666&#39;); }) console.log(resultList); npm run build打包看一下chrome效果 奈何这个世界上还有IE这种东西😣，IE上看一下效果 可以看一下报错的地方： eval(&quot;const name = &#39;Alan&#39;;\\r\\nconst list = [1, 8, 4, 6];\\r\\n\\r\\nconst resultList = list.filter(item =&gt; item &gt; 5);\\r\\n\\r\\nnew Promise(() =&gt; {\\r\\n console.log(&#39;666&#39;);\\r\\n})\\r\\n\\r\\nconsole.log(resultList);\\r\\n\\n\\n//# sourceURL=webpack:///./src/index.js?&quot;); 看来IE是识别不了ES6语法的，那我们这里就要借助babel处理了。 npm install --save-dev babel-loader @babel/core @babel/preset-env @babel/preset-env把ES6转化为ES5 @babel/corebabel核心内容 配置webpack { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 loader: &#39;babel-loader&#39;, options: { presets: [&#39;@babel/preset-env&#39;] } }, 再打包看一看 打包后的index.js文件 var name = &#39;Alan&#39;; var list = [1, 8, 4, 6]; var resultList = list.filter(function (item) { return item &gt; 5; }); new Promise(function () { console.log(&#39;666&#39;); }); console.log(resultList); 虽然处理了一些ES6语法（箭头函数，const），但是像filter和Promise还是没有处理的。 这里就要使用@babel-polyfill，它会模拟一个ES5环境 npm install --save @babel/polyfill安装后在文件开头引入就可以了 import &#39;@babel/polyfill&#39;; const name = &#39;Alan&#39;; const list = [1, 8, 4, 6]; const resultList = list.filter(item =&gt; item &gt; 5); new Promise(() =&gt; { console.log(&#39;666&#39;); }) console.log(resultList); 再次打包运行 虽然效果完成了，但是对比一下没使用@babel/polyfill和使用了@babel/polyfill打包后的大小😮 就引入了一个@babel-polyfill，体积就增加了这么多？ 其实是因为@babel-polyfill模拟了所有的ES5环境，而我们这里只使用了Promise和filter，所以我们可以通过配置useBuiltIns让它只模拟我们使用到的。 配置了useBuiltIns后，它是会自动帮我们引入@babel/polyfill所以这里我们无需再引入。 { test: /\\.js$/, exclude: /node_modules/, // 不对node_modules下的js文件处理 loader: &#39;babel-loader&#39;, options: { presets: [[&#39;@babel/preset-env&#39;, { useBuiltIns: &#39;usage&#39; }]] } }, main.js 68.6 KiB main [emitted] main 再看一下打包后的文件小了很多有没有？ babel的配置是可以单独放在.babelrc文件中的，直接将options中的内容放到.babelrc目录下即可 { &quot;presets&quot;: [[&quot;@babel/preset-env&quot;, { &quot;useBuiltIns&quot;: &quot;usage&quot; }]] } 使用@babel/preset-react打包React文件npm install --save-dev @babel/preset-react.babelrcindex.js{ \"presets\": [[\"@babel/preset-env\", { \"useBuiltIns\": \"usage\" }], \"@babel/preset-react\" ] }import React, { Component } from 'react'; import ReactDom from 'react-dom'; class App extends Component { render() { return ( &lt;div&gt;Hello React&lt;/div&gt; ); } } ReactDom.render(&lt;App /&gt;, document.getElementById('root')); 这里有一点需要注意一下，presets顺序是从后往前的，和css-loader一样，也就是js文件是先被@babel/preset-react处理的再被@babel/preset-env处理的。 总结使用的babel@babel/preset-react处理react的jsx语法 @babel-polyfill处理低版本浏览器无法处理的语法，类似Promise、Array.from、Object.assign @babel/preset-env把ES6转化为ES5 @babel/corebabel核心内容 useBuiltIns:usage按需引入 更多配置参考babel官网","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"webpack4.0学习总结（三）","slug":"webpack4.0学习总结（三）","date":"2020-05-17T02:05:14.000Z","updated":"2020-05-16T05:33:00.000Z","comments":true,"path":"posts/829819a3/","link":"","permalink":"https://alanwang.site/posts/829819a3/","excerpt":"这节介绍了webpack一些常用的plugins的使用","text":"这节介绍了webpack一些常用的plugins的使用 我的总结篇的第一节中提到了index.html是需要我们手动移动到打包后的dist目录下的，那我比较懒能不能让webpack来帮我完成呢。🤔 这个时候plugins就派上了用场。 html-webpack-plugin The HtmlWebpackPlugin simplifies creation of HTML files to serve your webpack bundles. This is especially useful for webpack bundles that include a hash in the filename which changes every compilation. You can either let the plugin generate an HTML file for you, supply your own template using lodash templates, or use your own loader. 官网介绍到，它可以帮我们自动创造HTML文件，并且还可以使用自定义的HTML模板。 直接看例子： npm i html-webpack-plugin -D webpacktest ├── package-lock.json ├── package.json ├── src │ └── index.js └── webpack.config.jsindex.js var root = document.getElementById(&#39;root&#39;); root.innerHTML = &#39;&lt;div&gt;Hello Webpack&lt;/div&gt;&#39; webpack.config.js const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); module.exports = { mode: &#39;development&#39;, // 默认为production entry: { main: &#39;./src/index.js&#39;, // 打包入口文件 }, output: { // 输出文件配置 filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;), }, plugins: [new HtmlWebpackPlugin()] }; npm run build进行打包看下结果 webpacktest ├── dist │ ├── bundle.js │ └── index.html ├── package-lock.json ├── package.json ├── src │ └── index.js └── webpack.config.jsHtmlWebpackPlugin插件自动为我们生成了index.html，但是…浏览器打开index.html一看什么都没有。这是咋回事，来看一看生成的index.html文件发现了问题 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Webpack App&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;/head&gt; &lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 生成的文件中是没有#root节点的，那怎么办？我们还需要配置一下HtmlWebpackPlugin，前面官网的介绍中也提到了 You can either let the plugin generate an HTML file for you, supply your own template using lodash templates, or use your own loader 我们需要自己提供一个HTML模板，于是在src目录下创建一个index.html作为HtmlWebpackPlugin打包的模板 index.htmlwebpack.config.js&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;html template&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;plugins: [new HtmlWebpackPlugin({ template: './src/index.html' })] 再打包一次看一下dist目录下生成的index.html文件和我们定义的html模板是一样的了。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;html template&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 打开浏览器发现Hello Webpack也正确显示出来了。🎉 clean-webpack-pluginhttps://www.npmjs.com/package/clean-webpack-plugin 它的作用就是在每次打包前会将webpack中配置的out.path(dist目录)清空 npm i clean-webpack-plugin -D为了验证是否清空了dist目录，我们先在dist目录下自己创建一个文件my.js dist ├── bundle.js ├── index.html └── my.jsconst path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;); module.exports = { mode: &#39;development&#39;, // 默认为production entry: { main: &#39;./src/index.js&#39;, // 打包入口文件 }, output: { // 输出文件配置 filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;), }, plugins: [new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39; }), new CleanWebpackPlugin()] }; npm run build打包 dist ├── bundle.js └── index.html我们发现之前创建的my.js文件已经被CleanWebpackPlugin给清除了。 多入口文件有时我们的打包入口文件有多个，这时候就要通过设置entry来完成打包。并通过[name]占位符来设置打包出来的文件的名称。 const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;); module.exports = { mode: &#39;development&#39;, // 默认为production entry: { main: &#39;./src/index.js&#39;, // 打包入口文件 enrty: &#39;./src/entry.js&#39;, }, output: { // 输出文件配置 filename: &#39;[name].js&#39;, path: path.resolve(__dirname, &#39;dist&#39;), }, plugins: [new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39; }), new CleanWebpackPlugin()] }; npm run build打包结果 dist ├── enrty.js ├── index.html └── main.js看一看index.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;html template&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;enrty.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 可以看到HtmlWebpackPlugin帮我们把main.js和entry.j2个文件都自动引入到html文件当中了。 在实际业务场景中，为了优化服务器性能，我们会将打包好的dist目录中的一部分文件丢到cdn中来加快访问速度。这时候我们就要将cdn的地址手动复制到打包后的html文件中了，不过我们可以通过设置output的publicPath来完成。 output: { // 输出文件配置 filename: &#39;[name].js&#39;, publicPath: &#39;https://cdn.example.com/assets&#39;, path: path.resolve(__dirname, &#39;dist&#39;), }, 打包后的效果 &lt;script src=&quot;https://cdn.example.com/assets/main.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.example.com/assets/enrty.js&quot;&gt;&lt;/script&gt; SourceMapsourcemap是什么，我们修改一下index.js文件内容并且在webpack配置中关闭sourcemap(devtool: ‘none’) index.js var root = document.getElementById(&#39;root&#39;); errfun(); root.innerHTML = &#39;&lt;div&gt;Hello Webpack&lt;/div&gt;&#39; webpack.config.js const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;); module.exports = { mode: &#39;development&#39;, // 默认为production devtool: &#39;none&#39;, entry: { main: &#39;./src/index.js&#39;, // 打包入口文件 enrty: &#39;./src/entry.js&#39;, }, output: { // 输出文件配置 filename: &#39;[name].js&#39;, path: path.resolve(__dirname, &#39;dist&#39;), }, plugins: [new HtmlWebpackPlugin({ template: &#39;./src/index.html&#39; }), new CleanWebpackPlugin()] }; index.js中使用了一个不存在的函数errfun()，打包运行一下是会报错的。 这个时候我们想要调试代码，但是它这里提示的错误行是打包后的main.js所在的位置。 现在我们配置sourcemap看看。 devtool: &#39;source-map&#39;, 这个时候我们就能定位到错误是出现在我们index.js的第三行了。 配置不同sourceMap会不同程度上增加应用的打包时间或消耗性能 官网提供了多种sourceMap配置，不同sourceMap打包消耗时间不同，详情。 sourcemap其实就是main.js和index.js之间的一种映射关系，在代码存在错误时，它能根据映射关系找到index.js中的错误所在处，有利于我们debug代码。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"webpack4.0学习总结（二）","slug":"webpack4.0学习总结（二）","date":"2020-05-15T12:00:22.000Z","updated":"2020-05-16T05:33:00.000Z","comments":true,"path":"posts/cf86baf1/","link":"","permalink":"https://alanwang.site/posts/cf86baf1/","excerpt":"这节主要讲一讲一些常见的Loder的使用。包括file-loader、url-loader以及css-loader和style-loader。","text":"这节主要讲一讲一些常见的Loder的使用。包括file-loader、url-loader以及css-loader和style-loader。 Loaderfile-loader上一节简单介绍了webpack是什么，webpack是一个模块打包器，可以将es的模块文件进行打包。上一节我们只打包了js文件，那我们能不能打包其他类型的文件呢，先来试一试打包图片吧。 这里使用到了file-loader npm i file-loader -Dindex.js // ES Moudule 模块化引入 import ComponentB from &#39;./componentB&#39;; var root = document.getElementById(&#39;root&#39;); // CommonJs 模块引入 var ComponentA = require(&#39;./componentA&#39;); var img1 = require(&#39;./IMG_3294.jpg&#39;); console.log(img1); var img = new Image(); img.src = img1; root.append(img); new ComponentA(); new ComponentB(); webpack.config.js const path = require(&#39;path&#39;); module.exports = { mode: &#39;development&#39;, // 默认为production entry: { main: &#39;./src/index.js&#39; // 打包入口文件 }, module: { rules: [ { test: /\\.jpg$/, use: { loader: &#39;file-loader&#39; } } ] }, output: { // 输出文件配置 filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) } } npm run build进行打包，我们看一下控制台打印出来的img1 这里可以看到img1是一个Module。 我们可以通过img1.default来获取路径或者直接通过import形式来引入，这样图片就成功得显示出来了😄 import img1 from &#39;./IMG_3294.jpg&#39; 通过这个例子可以知道了loader的大致作用方法了，通过test来匹配特定文件使用（use)特定的loader来对文件进行打包处理。 我们再看一下打包出来的文件 dist ├── a2099657cfcaf9f019ccf08e9dc8747d.jpg ├── bundle.js └── index.html发现我们的图片名称被改变成了一长串字符，那我怎么让它不改变名字呢。这时候loader的options就派上用场了😎 rules: [ { test: /\\.(jpg|png)$/, use: { loader: &#39;file-loader&#39;, options: { name: &#39;[name].[ext]&#39; } } } ] 这里的[name]和[ext]是loader中的placeholder,分别表示文件的名字和后缀名，当然loader中还有很多的placeholder。 设置好后进行打包得到如下结果 dist ├── bundle.js ├── IMG_3294.jpg └── index.html现在有一个问题，当我们的图片一旦多起来那全部打包放在根目录下拿岂不是很乱，这个时候就可以使用options中的output来规定经过loader处理后的输出路径了。 options: { name: &#39;[name].[ext]&#39;, outputPath: &#39;images/&#39; } 打包看一下结果成功👌，运行一下html文件图片也可以正常显示。 dist ├── bundle.js ├── images │ └── IMG_3294.jpg └── index.html到这里我们就了解了file-loader的基本使用了。 url-loaderurl-loader也可以打包文件，但是和file-loader不同的是，它会将我们的图片转化成base64编码，那如果我不想转化呢，我们可以使用options中的limit属性来限制文件在小于多少时转化成base64编码，一旦大于这个值打包出来的效果就和file-loader一样了。 看一下例子就清楚了 npm i url-loader -D这里准备两个图片，一个大小300k，一个大小7k webpack配置 const path = require(&#39;path&#39;); module.exports = { mode: &#39;development&#39;, // 默认为production entry: { main: &#39;./src/index.js&#39; // 打包入口文件 }, module: { rules: [ { test: /\\.(jpg|png)$/, use: { loader: &#39;url-loader&#39;, options: { name: &#39;[name].[ext]&#39;, outputPath: &#39;images/&#39;, limit: 10240 } } } ] }, output: { // 输出文件配置 filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) } } 看一下打包后的文件 dist ├── bundle.js ├── images │ └── 300k.jpg └── index.html结果是大于10240的300k.jpg文件被以图片形式打包出来了，那7k.jpg文件去哪了呢，我们在bundle.js文件中可以找到了它，它被转化成了base64编码。 data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD...当然limit也可以设置为true/false，更多配置 我在操作中发现了如果html中没有使用到7k.jpg，url-loader是不会对它进行打包的。 这里并不建议把大文件转化为base64，这样会增加bundle.js的体积，对项目优化不太友好 样式文件接着上面的例子，我现在想要为页面中的图片添加一些样式 index.js // ES Moudule 模块化引入 import ComponentB from &#39;./componentB&#39;; import &#39;./index.css&#39;; var root = document.getElementById(&#39;root&#39;); // CommonJs 模块引入 var ComponentA = require(&#39;./componentA&#39;); import img1 from &#39;./300k.jpg&#39;; console.log(img1); var img = new Image(); img.src = img1; img.classList.add(&#39;circle&#39;); root.append(img); new ComponentA(); new ComponentB(); index.css .circle { width: 100px; height: 100px; border-radius: 50px; } 现在我想要打包css文件该怎么办呢😶，我们要用到两个loader，css-loader和style-loader 安装 npm i style-loader css-loader -Dwebpack配置 { test: /\\.css$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] } 打包成功，打开网页看一看效果生效了 这里简单介绍一下style-loader和css-loader的作用，首先它们执行有先后顺序的，先使用css-loader对css文件进行打包，再用style-loader把打包后的css文件内容以&lt;style&gt;&lt;/style&gt;加到页面的header中。 有时候我们要为css加上浏览器引擎前缀-webkit，这里有一个loader可以帮我们完成postcss-loader 安装 npm i postcss-loader autoprefixer -Dwebpack配置 { test: /\\.css$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, { loader: &#39;postcss-loader&#39;, options: { ident: &#39;postcss&#39;, pulgins: [ require(&#39;autoprefixer&#39;) ] } }], }, 这里貌似有点问题，后期我再研究研究。 扩展css模块化先看一个场景 index.jscomponentA.jsimport './index.css'; import img1 from './300k.jpg'; import ComponentA from './componentA'; var root = document.getElementById('root'); var img = new Image(); img.src = img1; img.classList.add('circle'); root.append(img); ComponentA();import img1 from './300k.jpg'; function ComponentA() { var img = new Image(); img.src = img1; img.classList.add('circle'); var root = document.getElementById('root'); root.append(img); } export default ComponentA; 我们看到circle样式同样作用在了componentA上了，也就是说circle已经等同于是全局样式了😥。还好我们可以通过配置css-loader的options来使用css的模块化来解决这个问题。 { test: /\\.css$/, use: [ &#39;style-loader&#39;, { loader: &#39;css-loader&#39;, options: { modules: true, } }, { loader: &#39;postcss-loader&#39;, options: { ident: &#39;postcss&#39;, pulgins: [require(&#39;autoprefixer&#39;)], }, }, ], }, 配置好后我们在要使用样式的地方使用下面这种写法 import circle from &#39;./index.css&#39;; img.classList.add(circle.circle); 这样我们再修改样式就不会影响到其他地方了。 css外部引入这里主要介绍css-loader的optionsimportLoaders。 我们在index.css文件中引入外部css文件 @import &#39;./import.css&#39;; 假设我们有以下几个loader处理css文件 [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;, &#39;postcss-loader&#39;] 当webpack处理index.css文件时按照postcss-loader-&gt;sass-loader-&gt;css-loader顺序来执行css文件的 当遇到@import时处理import.css时，如果不做处理的话，import.css将直接从css-loader开始处理的，那我想让它从postcss-loader从头处理的话就要设置imortLoaders数目了。 { loader: &#39;css-loader&#39;, options: { importLoaders: 1, } }, 这里的1表示处理@import引入的css文件是，先要被前面的1个loader处理，也就是import.css的处理顺序是sass-loader-&gt;css-loader-style-loader。 处理字体文件直接使用file-loader处理就可以了 webpack.config.jsindex.jsiconfont.css{ test: /\\.(eot|ttf|svg|woff)$/, use: { loader: 'file-loader', }, },import './font/iconfont.css'; var root = document.getElementById('root'); root.innerHTML = '&lt;div class=\"iconfont icon-smile\"&gt;&lt;/div&gt;'@font-face {font-family: \"iconfont\"; src: url('iconfont.eot?t=1589604469136'); /* IE9 */ src: url('iconfont.eot?t=1589604469136#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('data:application/x-font-woff2;charset=utf-8;base64,这里base64代码太长删除掉了') format('woff2'), url('iconfont.woff?t=1589604469136') format('woff'), url('iconfont.ttf?t=1589604469136') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url('iconfont.svg?t=1589604469136#iconfont') format('svg'); /* iOS 4.1- */ } .iconfont { font-family: \"iconfont\" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } .icon-smile:before { content: \"\\e783\"; } ok!这章到此介绍。现在我们已经能够处理一些常见文件的打包了，对webpack的认识也应该算一个简单的入门了。😁","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"webpack4.0学习总结（一）","slug":"webpack4.0学习总结（一）","date":"2020-05-14T08:01:46.000Z","updated":"2020-05-14T08:01:46.000Z","comments":true,"path":"posts/ff905629/","link":"","permalink":"https://alanwang.site/posts/ff905629/","excerpt":"这一篇文章主要简单介绍了webpack是什么以及webpack的一些简单配置，你只要跟着我敲完这些代码后一定会对webpack有一个基本的了解的。😎","text":"这一篇文章主要简单介绍了webpack是什么以及webpack的一些简单配置，你只要跟着我敲完这些代码后一定会对webpack有一个基本的了解的。😎 webpack是一个模块打包器 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 上面引用了webpack官网的一段介绍，我们可以简单的理解webpack是一个模块打包器，那什么是模块打包器呢？😂先看一个简单的例子 index.htmlindex.jscomponentA.jscomponentB.js&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;// ES Moudule 模块化引入 import ComponentB from './componentB'; var root = document.getElementById('root'); // CommonJs 模块引入 var ComponentA = require('./componentA'); new ComponentA(); new ComponentB(); function ComponentA() { var componentA = document.createElement('div'); componentA.innerHTML = 'ComponentA'; root.append(componentA); } module.exports = ComponentA;function ComponentB() { var componentB = document.createElement('div'); componentB.innerHTML = 'ComponentB'; root.append(componentB); } export default ComponentB; 这里的模块可以理解成componentA和componentB，这种写法在vue和react中非常常见，写完这些文件后打开index.html文件，浏览器是会报错的。 Uncaught SyntaxError: Cannot use import statement outside a module 这是由于这里使用了es6中的模板引入的方式，浏览器是识别不了这种方式的，那怎么办呢？😥 这个时候webpack就派上用场了，首先初始化该项目 npm init -y初始化后会生成package.json文件 安装webpack-cli和webpack（不建议全局安装） npm install webpack-cli -D npm install webpack -S安装固定版本的webpack npm install webpack@版本号 npm info webpack // 查看包信息打包index.js npx webpack index.js 这里如果不使用npx的话node会默认在全局环境中找寻webpack，加上npx的话就会使用项目中安装的webpack来执行命令 打包后可以看到根目录下多了一个dist文件夹（webpack默认设置好的，后面会讲如何改变），里面有一个main.js文件，这个文件就是经过webpack处理后的index.js。 然后我们修改一下index.html的代码 &lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt; 这下浏览器就能正常识别html中的js文件了，到这里为止理解webpack是一个模块打包器应该不是很难了吧。webpack将模块componentA和componentB打包生成了最后的main.js。 webpack配置文件webpack的配置文件名默认是webpack.config.js，当然我们也可以指定配置文件。 开始之前我们先修改一下项目目录 webpacktest ├── index.html ├── package-lock.json ├── package.json ├── src │ ├── componentA.js │ ├── componentB.js │ └── index.js └── webpack.config.js在项目根目录下新建配置文件webpack.config.js： const path = require(&#39;path&#39;); module.exports = { mode: &#39;development&#39;, // 默认为production entry: { main: &#39;./src/index.js&#39; // 打包入口文件 }, output: { // 输出文件配置 filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) } } 上面引用的path是node中的一个模块，__dirname表示webpack.config.js所在的目录。 entry可以简写为entry: ‘./src/index.js’ mode中的development和production有什么区别呢 我们看一下打包出来的文件bundle.js就知道了，production模式下的代码是一整行的，体积更小。而development模式下的代码不是一整行的有利于调试。 node path的 更多 执行下面命令后即可完成打包，效果和上一节一样 npx webpack当然也可以使用自定义配置文件 npx webpack --config 自定义配置文件写过项目的小伙伴应该都发现平时都是使用npm run xxx来打包项目的，下面就来介绍一下如何配置 修改package.json文件中的script &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot; }, 这样就可以通过npm run build来进行打包了，不过看过第一节的小伙伴肯定有疑问了，这样配置会不会使用全局的webpack去进行打包呢🙄，其实并不会，这里npm script命令会在项目的node_modules文件中去寻找webpack并执行。 打包好后我们打开index.html看看，发现是会报错的，这里注意：我们要手动把index.html移动到dist目录下并修改一下js路径，因为webpack并没有将index.html打包到dist目录下。 &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt; 这下再运行index.html就没有任何问题了。🎉","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"}]},{"title":"react博客-egg-jwt实现登录系统","slug":"react博客-egg-jwt实现登录系统","date":"2020-05-13T08:11:11.000Z","updated":"2020-05-13T08:11:11.000Z","comments":true,"path":"posts/3b0a6cbe/","link":"","permalink":"https://alanwang.site/posts/3b0a6cbe/","excerpt":"react博客系列文章","text":"react博客系列文章 何为jwtegg-jwt安装egg-jwtyarn add egg-jwt 配置egg-jwt 配置config/plugin.js文件 exports.jwt = { enable: true, package: &#39;egg-jwt&#39;, }; 配置config/config.default.js文件 // 自己设定的密钥，用于对信息进行签名 config.jwt = { secret: &#39;xxxxxx&#39;, }; 实例后台实现登录操作返回token 路由层 在第二个参数上加上jwt即可实现对该路由的鉴权 下面的jwt是自定义的中间件auth.js，该文件在下一部分介绍 &#39;use strict&#39;; /** * @param {Egg.Application} app - egg application */ module.exports = app =&gt; { const { router, controller, middleware, config } = app; const { admin } = controller.admin; const jwt = middleware.auth(config.jwt); router.post(&#39;/admin/login&#39;, admin.login); // 需要鉴权的路由再第二个参数上加上jwt router.get(&#39;/admin/get_type_list&#39;, jwt, admin.getTypeList); }; controller层 使用jwt.sign(加密数据, 密钥, [options, callback]) 来生成token 相关配置可以查看jsonwebtoken async login() { const { app, ctx } = this; const { username, password } = ctx.request.body; const checkValidate = await ctx.service.admin.admin.checkUserValidate(username, password); if (checkValidate) { // 将信息使用jwt进行签名加密生成token，expiresIn（token有效时间） const token = app.jwt.sign({ username, password }, app.config.jwt.secret, { expiresIn: &#39;2h&#39; }); ctx.body = { code: &#39;0001&#39;, msg: &#39;登录成功&#39;, token, }; } else { ctx.body = { code: &#39;0002&#39;, msg: &#39;用户名或者密码错误，请重试！&#39;, }; } } service层 async checkUserValidate(username, password) { const isValidate = await this.app.mysql.get(&#39;admin&#39;, { username, password }); return !!isValidate; } 使用postman进行测试 将生成的token返回给前台后使用localStorage.setItem把token保存到本地 前台传递token进行鉴权封装axios新建axios文件对axio进行封装，通过axios的拦截器来实现每次请求时自动在headers上携带token数据到后台，后台使用jwt.verify来检验token的正确性 axios.js import axios from &#39;axios&#39;; axios.interceptors.request.use(config =&gt; { // 登录成功后保存在本地的token const token = localStorage.getItem(&#39;token&#39;); config.headers.Authorization = `Bearer ${token}`; return config; }); axios.interceptors.response.use(response =&gt; { // code是后台接口设置的 const { code } = response.data; if (code === &#39;0003&#39; || code === &#39;0004&#39;) { window.location.href = &#39;/login&#39;; } return response; }); export default axios; 封装好后，之后都使用该封装好后的axios进行请求。 后台校验处理auth.js &#39;use strict&#39;; module.exports = options =&gt; { return async function auth(ctx, next) { // 获取前台通过axios封装后穿过来的token const token = ctx.header.authorization; if (token) { try { // 验证并对token进行解码 const decode = ctx.app.jwt.verify(token.split(&#39; &#39;)[1], options.secret); console.log(decode); await next(); } catch (error) { console.log(error.name); if (error.name === &#39;JsonWebTokenError&#39; || error.name === &#39;TokenExpiredError&#39;) { // 这里的错误有许多种情况：1.token错误，2.token过期... 这里统一处理为鉴权失败 ctx.body = { code: &#39;0003&#39;, msg: &#39;用户鉴权失败，请重新登录&#39;, }; } else { throw error; } } } else { ctx.body = { code: &#39;0004&#39;, msg: &#39;您没有登录，请先登录&#39;, }; } }; }; 后台通过/middleware/auth.js中间件来实现给需要鉴权的接口进行鉴权，通过对前台传过来的token数据进行验证jwt.verify来识别登录状态。对JsonWebTokenError错误统一处理，应为auth.js作为中间件，所以接口中出现的其他错误也会在这里被catch到，对于不是JsonWebTokenError的错误，直接把错误抛出去。","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"},{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"ReactHook","slug":"ReactHook","permalink":"https://alanwang.site/tags/ReactHook/"},{"name":"jwt","slug":"jwt","permalink":"https://alanwang.site/tags/jwt/"}]},{"title":"react博客-项目部署","slug":"react博客-项目部署","date":"2020-05-13T07:51:16.000Z","updated":"2020-05-13T07:51:16.000Z","comments":true,"path":"posts/d4ddb122/","link":"","permalink":"https://alanwang.site/posts/d4ddb122/","excerpt":"阿里云最近推出了一个“在家实践活动”，免费领取半年的服务器，真香。领取地址","text":"阿里云最近推出了一个“在家实践活动”，免费领取半年的服务器，真香。领取地址 购买阿里云服务器购买完成后会得到一个公网ip 下载软件putty来连接我们刚才购买的服务器，只需输入公网ip点击open即可 在命令行中输入用户名root和密码得到Welcome to Alibaba Cloud Elastic Compute Service !即完成了连接。 使用宝塔进行管理https://www.bt.cn/bbs/thread-19376-1-1.html 连接成功服务器后在命令行输入(Centos系统，其他系统查看上面网址)，复制按下鼠标右键完成宝塔的安装 yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh安装成功后会返回一个端口号为8888的网站以及账号和密码： 访问该地址，这个时候网站时不能访问的，因为远程服务器没有开放8888端口。 设置教程： https://www.bt.cn/bbs/thread-2897-1-1.html 登录成功后安装mysql和nginx（之后几乎所有的操作都在宝塔上进行） 需要安装软件 php环境（用于phpmyadmin） phpMyAdmin（用于管理mysql数据库） PM2（自带node环境） nginx 开放80(http)端口访问服务器在阿里云服务器管理控制台安全组中设置 设置后就可以通过公网ip访问服务器了 部署项目切换镜像源安装nrm（用来管理npm镜像源的工具）npm install -g nrm 常用命令 nrm ls 查看所有源地址 nrm use taobao 切换为淘宝镜像源 nrm add [name] [url] 添加源地址 通过git克隆代码到服务器把代码clone到服务器 打包项目并且部署 部署前台页面（next.js） yarn build yarn start 或者用PM2进行进程守护（待研究） 部署后台接口（egg.js） npm start 部署后台管理系统 直接npm build然后使用nginx进行代理 导入mysql数据出错在导入本地mysql文件时遇到了一些错误，参考文章： https://www.jianshu.com/p/788dceb93eff Linux查看端口号占用情况以及杀进程命令 netstart -anp（查看端口占用情况） lsof -i:8080（查看8080端口占用情况） kill -9 1234（杀PID=1234进程）","categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"},{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"部署","slug":"部署","permalink":"https://alanwang.site/tags/%E9%83%A8%E7%BD%B2/"},{"name":"阿里云","slug":"阿里云","permalink":"https://alanwang.site/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}]},{"title":"测试主题","slug":"test1","date":"2020-05-13T01:19:17.000Z","updated":"2020-05-13T07:19:17.000Z","comments":true,"path":"posts/f032f0/","link":"","permalink":"https://alanwang.site/posts/f032f0/","excerpt":"这里是摘要","text":"这里是摘要 这里是正文 title: 测试主题 date: 2020-05-13 09:19:17 top: true categories: 测试分类 tags: 测试标签 author: name: 测试作者 avatar: https://gitee.com/alannum3/MyImages/raw/master/img/20200508165134.png music: # 文章音乐 server: netease # netease, tencent, kugou, xiami, baidu type: song # song, playlist, album, search, artist id: 16846091 thumbnail: # 文章缩略图 https://gitee.com/alannum3/MyImages/raw/master/img/20200508165134.png # 归档页面对应文章图标 icons: [fas fa-fire red, fas fa-star green] meta: # 文章底部按钮 footer: [btns] btns: repo: https://github.com/xaoxuu/hexo-theme-volantis bug: https://github.com/xaoxuu/hexo-theme-volantis/issues/ doubt: https://github.com/xaoxuu/hexo-theme-volantis/issues/ idea: https://github.com/xaoxuu/hexo-theme-volantis/issues/ cover: false #是否显示封面图 h1h2h3代码块index.jsindex.jsindex.jsjsdalkjfdajsdalkjfdajsdalkjfda index.jsjsdalkjfda index.jsjsdalkjfda index.jsjsdalkjfda","categories":[{"name":"测试分类","slug":"测试分类","permalink":"https://alanwang.site/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"测试标签","slug":"测试标签","permalink":"https://alanwang.site/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"}]},{"title":"Typora+PicGo+Gitee（书写博客神器）","slug":"Typora-PicGo-Gitee（书写博客神器）","date":"2020-05-12T13:06:52.000Z","updated":"2020-05-15T12:49:17.000Z","comments":true,"path":"posts/24b4915a/","link":"","permalink":"https://alanwang.site/posts/24b4915a/","excerpt":"写博客，难免会随手截图来解释博客中的一些知识点或者内容。当高高兴兴地在本地电脑写完博客后将它上传之后发现所有图片都浏览不了了，这其实就是因为图片都保存在本地了。为了解决这个问题，从长远和财力来考虑，我使用了gitee搭配开源项目PicGo来做图床生成在线图片链接，这样无论在哪都能畅通查看图片了。而不使用github主要是国内访问速度是非常地慢。","text":"写博客，难免会随手截图来解释博客中的一些知识点或者内容。当高高兴兴地在本地电脑写完博客后将它上传之后发现所有图片都浏览不了了，这其实就是因为图片都保存在本地了。为了解决这个问题，从长远和财力来考虑，我使用了gitee搭配开源项目PicGo来做图床生成在线图片链接，这样无论在哪都能畅通查看图片了。而不使用github主要是国内访问速度是非常地慢。 参考文章：https://blog.csdn.net/disILLL/article/details/104944710 开搞软件版本 typora 0.9.86 PicGo 2.2.2 创建gitee仓库在gitee账户中创建一个公开的仓库用来保存图片 PicGo配置这边安装有一个巨坑，不要安装在Programe Files目录下面，切记 安装gitee-uploader插件 安装完后配置gitee token在自己的gitee中创建 点击commit生成token，将token填入PicGo中点击确定即可。 检查一下端口号是不是36677，这是我踩过的一个坑 配置Typora实现插入图片自动上传新版本的Typora已经支持图片上传功能，具体配置如下（文件-&gt;偏好设置）： 测试可以看到这里图片的链接是之前在gitee中创建的用来保存图片的Repository的地址了 哈哈，成功了，这样效率就提高了许多了。","categories":[{"name":"效率工具","slug":"效率工具","permalink":"https://alanwang.site/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://alanwang.site/tags/Typora/"},{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"工具","slug":"工具","permalink":"https://alanwang.site/tags/%E5%B7%A5%E5%85%B7/"}]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/React/"},{"name":"TypeScript","slug":"前端/TypeScript","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/TypeScript/"},{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://alanwang.site/categories/Hexo%E5%8D%9A%E5%AE%A2/"},{"name":"webpack4.0学习总结","slug":"前端/webpack4-0学习总结","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/webpack4-0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"},{"name":"面试造轮","slug":"前端/面试造轮","permalink":"https://alanwang.site/categories/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%80%A0%E8%BD%AE/"},{"name":"记录生活","slug":"记录生活","permalink":"https://alanwang.site/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"},{"name":"2020","slug":"记录生活/2020","permalink":"https://alanwang.site/categories/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/2020/"},{"name":"测试分类","slug":"测试分类","permalink":"https://alanwang.site/categories/%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"},{"name":"效率工具","slug":"效率工具","permalink":"https://alanwang.site/categories/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"React","slug":"React","permalink":"https://alanwang.site/tags/React/"},{"name":"Next.js","slug":"Next-js","permalink":"https://alanwang.site/tags/Next-js/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://alanwang.site/tags/TypeScript/"},{"name":"Hexo","slug":"Hexo","permalink":"https://alanwang.site/tags/Hexo/"},{"name":"Valine国际版","slug":"Valine国际版","permalink":"https://alanwang.site/tags/Valine%E5%9B%BD%E9%99%85%E7%89%88/"},{"name":"Hexo评论系统","slug":"Hexo评论系统","permalink":"https://alanwang.site/tags/Hexo%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"name":"DIY博客","slug":"DIY博客","permalink":"https://alanwang.site/tags/DIY%E5%8D%9A%E5%AE%A2/"},{"name":"webpack4.0","slug":"webpack4-0","permalink":"https://alanwang.site/tags/webpack4-0/"},{"name":"面试题","slug":"面试题","permalink":"https://alanwang.site/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"记录生活","slug":"记录生活","permalink":"https://alanwang.site/tags/%E8%AE%B0%E5%BD%95%E7%94%9F%E6%B4%BB/"},{"name":"博客","slug":"博客","permalink":"https://alanwang.site/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"ReactHook","slug":"ReactHook","permalink":"https://alanwang.site/tags/ReactHook/"},{"name":"jwt","slug":"jwt","permalink":"https://alanwang.site/tags/jwt/"},{"name":"部署","slug":"部署","permalink":"https://alanwang.site/tags/%E9%83%A8%E7%BD%B2/"},{"name":"阿里云","slug":"阿里云","permalink":"https://alanwang.site/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"测试标签","slug":"测试标签","permalink":"https://alanwang.site/tags/%E6%B5%8B%E8%AF%95%E6%A0%87%E7%AD%BE/"},{"name":"Typora","slug":"Typora","permalink":"https://alanwang.site/tags/Typora/"},{"name":"工具","slug":"工具","permalink":"https://alanwang.site/tags/%E5%B7%A5%E5%85%B7/"}]}